<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">
    <service verb="store" noun="TalentProfileType">
        <description></description>
        <in-parameters>
            <parameter name="emplPositionClassId" default="title.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <parameter name="title" required="true"/>
            <parameter name="description"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
        </out-parameters>
        <actions>
            <service-call name="store#mantle.humanres.position.EmplPositionClass" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfileTypeDimensionType">
        <description></description>
        <in-parameters>
            <parameter name="uomDimensionTypeId" default="description.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <parameter name="description" required="true"/>
            <parameter name="uomTypeEnumId"/>
            <parameter name="defaultUomId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="uomDimensionTypeId"/>
        </out-parameters>
        <actions>
            <service-call name="store#moqui.basic.UomDimensionType" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="storeAndAdd" noun="TalentProfileTypeDimensionType">
        <implements service="resistmanagement.ProfileServices.store#TalentProfileTypeDimensionType"/>
        <in-parameters>
            <parameter name="emplPositionClassId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
            <parameter name="enumId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ProfileServices.store#TalentProfileTypeDimensionType" in-map="context" out-map="context"/>
            <service-call name="store#mantle.humanres.position.EmplPositionClassDimension" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfileTypeClassificationType">
        <description></description>
        <in-parameters>
            <parameter name="enumId"/>
            <parameter name="enumTypeId" default-value="PartyClassificationType"/>
            <parameter name="enumCode"/>
            <parameter name="sequenceNum"/>
            <parameter name="description" required="true"/>
            <parameter name="optionValue"/>
            <parameter name="optionIndicator"/>
        </in-parameters>
        <out-parameters>
            <parameter name="enumId"/>
        </out-parameters>
        <actions>
            <set field="enumId" from="enumId ?: camelCaseToPretty(enumTypeId).split(' ').collect{ it[0] }.join('').toLowerCase().capitalize() + description.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <service-call name="store#moqui.basic.Enumeration" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="storeAndAdd" noun="TalentProfileTypeClassificationType">
        <implements service="resistmanagement.ProfileServices.store#TalentProfileTypeClassificationType"/>
        <in-parameters>
            <parameter name="emplPositionClassId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
            <parameter name="enumId"/>
            <parameter name="classificationTypeEnumId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ProfileServices.store#TalentProfileTypeClassificationType" in-map="context" out-map="context"/>
            <set field="classificationTypeEnumId" from="enumId"/>
            <service-call name="store#mantle.party.EmplPositionClassPtyClsTp" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfileTypeClassificationTypeAttribute">
        <description></description>
        <in-parameters>
            <parameter name="partyClassificationId"/>
            <parameter name="classificationTypeEnumId" required="true"/>
            <parameter name="parentClassificationId"/>
            <parameter name="description" required="true"/>
            <parameter name="standardCode"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyClassificationId"/>
        </out-parameters>
        <actions>
            <set field="partyClassificationId" from="partyClassificationId ?: camelCaseToPretty(classificationTypeEnumId).split(' ')[0].toLowerCase().capitalize() + description.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <service-call name="store#mantle.party.PartyClassification" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfileTypeSkillType">
        <description></description>
        <in-parameters>
            <parameter name="enumId"/>
            <parameter name="enumTypeId" default-value="SkillType"/>
            <parameter name="enumCode"/>
            <parameter name="sequenceNum"/>
            <parameter name="description" required="true"/>
            <parameter name="optionValue"/>
            <parameter name="optionIndicator"/>
        </in-parameters>
        <out-parameters>
            <parameter name="enumId"/>
        </out-parameters>
        <actions>
            <set field="enumId" from="enumId ?: camelCaseToPretty(enumTypeId).split(' ').collect{ it[0] }.join('').toLowerCase().capitalize() + description.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <service-call name="store#moqui.basic.Enumeration" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="storeAndAdd" noun="TalentProfileTypeSkillType">
        <in-parameters>
            <parameter name="emplPositionClassId" required="true"/>
            <parameter name="enumId"/>
            <parameter name="enumTypeId" default-value="SkillType"/>
            <parameter name="enumCode"/>
            <parameter name="sequenceNum"/>
            <parameter name="description" required="true"/>
            <parameter name="optionValue"/>
            <parameter name="optionIndicator"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
            <parameter name="enumId"/>
            <parameter name="skillTypeEnumId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ProfileServices.store#TalentProfileTypeSkillType" in-map="context" out-map="context"/>
            <set field="skillTypeEnumId" from="enumId"/>
            <service-call name="store#mantle.humanres.position.EmplPositionClassSkill" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="PartyClassificationAppl">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="classificationTypeEnumId" required="true"/>
            <parameter name="partyClassificationId"/>
            <parameter name="fromDate" required="true" default="ec.user.nowTimestamp"/>
            <auto-parameters entity-name="mantle.party.PartyClassificationAppl" include="nonpk"/>
        </in-parameters>
        <out-parameters>
            <auto-parameters entity-name="mantle.party.PartyClassificationAppl"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.party.PartyClassificationAndAppl" list="pcapList">
                <econdition field-name="partyId"/><econdition field-name="classificationTypeEnumId"/>
                <date-filter/><order-by field-name="-thruDate,-fromDate"/></entity-find>
            <iterate list="pcapList" entry="pcap">
                <set field="pcapOut" from="pcap"/><set field="pcapOut.thruDate" from="ec.user.nowTimestamp"/>
                <service-call name="update#mantle.party.PartyClassificationAppl" in-map="pcapOut"/></iterate>

            <if condition="partyId &amp;&amp; partyClassificationId &amp;&amp; fromDate">
                <service-call name="store#mantle.party.PartyClassificationAppl" in-map="context" out-map="context"/></if>
        </actions>
    </service>

    <service verb="set" noun="PartySkills">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="emplPositionClassId" required="true"/>
            <parameter name="skillTypeEnumIdList" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="skillTypeEnumIdList"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.humanres.position.EmplPositionClassSkill" list="epcsList">
                <econdition field-name="emplPositionClassId"/></entity-find>
            <entity-find entity-name="mantle.humanres.ability.PartySkill" list="psList">
                <econdition field-name="skillTypeEnumId" operator="in" from="epcsList.skillTypeEnumId"/>
                <econdition field-name="partyId"/></entity-find>

<!--            <log level="warn" message="epcsList.skillTypeEnumId ${epcsList.skillTypeEnumId}"/>-->
<!--            <log level="warn" message="psList.skillTypeEnumId ${psList.skillTypeEnumId}"/>-->
<!--            <log level="warn" message="skillTypeEnumIdList ${skillTypeEnumIdList}"/>-->

            <iterate list="epcsList" entry="epcs">
                <if condition="skillTypeEnumIdList?.contains(epcs.skillTypeEnumId) &amp;&amp; !psList.skillTypeEnumId.contains(epcs.skillTypeEnumId)"><then>
<!--                    <log level="warn" message="create ${epcs.skillTypeEnumId}"/>-->
                    <service-call name="create#mantle.humanres.ability.PartySkill" in-map="[partyId:partyId, skillTypeEnumId:epcs.skillTypeEnumId]"/>
                </then><else-if condition="!skillTypeEnumIdList?.contains(epcs.skillTypeEnumId) &amp;&amp; psList.skillTypeEnumId.contains(epcs.skillTypeEnumId)">
<!--                    <log level="warn" message="delete ${epcs.skillTypeEnumId}"/>-->
                    <service-call name="delete#mantle.humanres.ability.PartySkill" in-map="[partyId:partyId, skillTypeEnumId:epcs.skillTypeEnumId]"/>
                </else-if><else-if condition="skillTypeEnumIdList?.contains(epcs.skillTypeEnumId) &amp;&amp; psList.skillTypeEnumId.contains(epcs.skillTypeEnumId)">
<!--                    <log level="warn" message="both exist ${epcs.skillTypeEnumId}"/>-->
                </else-if><else-if condition="!skillTypeEnumIdList?.contains(epcs.skillTypeEnumId) &amp;&amp; !psList.skillTypeEnumId.contains(epcs.skillTypeEnumId)">
<!--                    <log level="warn" message="neither exist ${epcs.skillTypeEnumId}"/>-->
                </else-if></if>
            </iterate>
        </actions>
    </service>

    <service verb="get" noun="ProfilePictureInfo">
        <in-parameters>
            <parameter name="partyId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="firstChar" required="true"/>
            <parameter name="primaryColor" required="true"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.Party" value-field="party">
                <field-map field-name="partyId"/></entity-find-one>
            <set field="firstChar" from="(party?.pseudoId ?: '?')[0].toUpperCase()"/>
            <set field="colorList" type="NewList" from="['#fbf8ccff', '#fde4cfff', '#ffcfd2ff', '#f1c0e8ff', '#cfbaf0ff', '#a3c4f3ff', '#90dbf4ff', '#8eecf5ff', '#98f5e1ff', '#b9fbc0ff']"/>
            <set field="primaryColor" from="colorList[Math.abs( new Random().nextInt(colorList.size()) )]"/>
        </actions>
    </service>

    <service verb="get" noun="SupportedImageFileTypeList">
        <in-parameters>
            <parameter name="supportedImageFileTypeList" type="List" default="['image/jpeg', 'image/png', 'image/svg+xml', 'image/webp', 'image/apng', 'image/avif', 'image/gif']"><description>
                See: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types for this list.</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="supportedImageFileTypeList" type="List"/>
        </out-parameters>
        <actions></actions>
    </service>

    <service verb="upload" noun="PartyContent">
        <description>
            Upload a file for a Party to create a PartyContent entry.

            If a file is not uploaded, there is no defaultFileName, AND there is no defaultFileRenderLocation, then an error is thrown that a file must be uploaded.
        </description>
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="partyContentTypeEnumId" required="true"/>
            <parameter name="defaultFileName"/>
            <parameter name="defaultFileRenderLocation"><description>Screen location to render the default file. Defaults to the text render mode.</description></parameter>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
            <parameter name="saveContentLocation" type="Boolean" default="true"/>
            <parameter name="fileMimeTypeList" required="true" default="ec.service.sync().name('resistmanagement.ProfileServices.get#SupportedImageFileTypeList').call().supportedImageFileTypeList"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyContentId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
<!--            <set field="test" from="fileMimeTypeList.collect{ fileMimeTypeList.indexOf(it) &lt; fileMimeTypeList.size() -1 ? it.split('/')[1].split('\\+')[0] : 'or ' + it.split('/')[1].split('\\+')[0] }.join(', ')"/>-->
<!--            <log level="warn" message="test ${test}"/>-->

            <if condition="contentFile != null &amp;&amp; !fileMimeTypeList.contains(contentFile.getContentType())">
                <!-- see: https://www.javacodeexamples.com/solution-java-util-regex-patternsyntaxexception-dangling-meta-character-near-index-0/3446 for why not split('+') and is split('\\+') -->
                <!-- see: https://freemarker.apache.org/docs/dgui_misc_autoescaping.html for why not split('\\+') and is split('\\\\+') -->
                <return error="true" message="The file type you used: ${contentFile.getContentType().split('/')[1].split('\\\\+')[0] } is not supported. Please upload a ${fileMimeTypeList.collect{ fileMimeTypeList.indexOf(it) &lt; fileMimeTypeList.size() -1 ? it.split('/')[1].split('\\\\+')[0] : 'or ' + it.split('/')[1].split('\\\\+')[0] }.join(', ')} file format."/>
            </if>
            <if condition="!defaultFileName &amp;&amp; !defaultFileRenderLocation &amp;&amp; contentFile == null"><return error="true" message="File upload is required."/></if>

            <set field="filename" from="contentFile?.getName() ?: defaultFileName"/>
            <if condition="org.moqui.resource.ResourceReference.isTextFilename(filename)"><then>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
            </then><else>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.large.root') ?: 'dbresource://mantle/content'"/>
            </else></if>

            <entity-find entity-name="mantle.party.PartyContent" list="pcList">
                <econdition field-name="partyId"/>
                <econdition field-name="partyContentTypeEnumId"/>
                <econdition field-name="contentLocation" operator="like" value="${contentRoot}/party/${partyId}/content_%/${filename}"/>
                <order-by field-name="-contentDate"/>
            </entity-find>

            <if condition="pcList?.size() &gt; 0">
                <service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:pcList.getFirst().partyContentId, contentDate:ec.user.nowTimestamp]" out-map="context"/>
                <return message="Using existing file with the name ${filename}"/>
            </if>
            <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:partyContentTypeEnumId]" out-map="context"/>

            <set field="contentLocation" value="${contentRoot}/party/${partyId}/content_${partyContentId}/${filename}"/>

            <set field="docRr" from="ec.resource.getLocationReference(contentLocation)"/>
            <script>
                fileStream = contentFile?.getName() ? contentFile.getInputStream() : new ByteArrayInputStream(ec.screen.makeRender().rootScreen(defaultFileRenderLocation).webappName(null).renderMode('text').render().getBytes())
                try { docRr.putStream(fileStream) } finally { fileStream.close() }
            </script>

            <if condition="saveContentLocation"><service-call name="update#mantle.party.PartyContent"
                                                              in-map="[partyContentId:partyContentId, contentLocation:contentLocation]"/></if>
        </actions>
    </service>

    <service verb="upload" noun="ProfilePictureAttachment">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyContentId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ProfileServices.upload#PartyContent" in-map="context + [
                partyContentTypeEnumId:'PcntPrimaryImage', defaultFileName:'DefaultProfilePicture.svg',
                defaultFileRenderLocation:'component://resistmanagement/screen/resistmanagement/DefaultProfilePicture.xml']" out-map="context"/>
        </actions>
    </service>

    <service verb="upload" noun="PostAttachment">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
            <parameter name="outputImageFormat" required="true" default-value="jpg"></parameter>
            <parameter name="saveOriginal" type="Boolean" default="true" required="true"><description>If true, will save the original image.</description></parameter>
            <parameter name="saveLarge" type="Boolean" default="false" required="true"><description>If true, will save a large image.</description></parameter>
            <parameter name="saveMedium" type="Boolean" default="true" required="true"><description>If true, will save a medium image.</description></parameter>
            <parameter name="saveSmall" type="Boolean" default="true" required="true"><description>If true, will save a small image.</description></parameter>
            <parameter name="saveThumbnail" type="Boolean" default="false" required="true"><description>If true, will save the thumbnail image.</description></parameter>
            <parameter name="contentTypeOriginal" default-value="PcntPostImageOriginal" required="true"><description>Party Content Type Enum Id for the Original image.</description></parameter>
            <parameter name="contentTypeLarge" default-value="PcntPostImageLarge" required="true"><description>Party Content Type Enum Id for the Large image.</description></parameter>
            <parameter name="contentTypeMedium" default-value="PcntPostImageMedium" required="true"><description>Party Content Type Enum Id for the Medium image.</description></parameter>
            <parameter name="contentTypeSmall" default-value="PcntPostImageSmall" required="true"><description>Party Content Type Enum Id for the Small image.</description></parameter>
            <parameter name="contentTypeThumbnail" default-value="PcntPostImageThumbnail" required="true"><description>Party Content Type Enum Id for the Thumbnail image.</description></parameter>
            <parameter name="fileMimeTypeList" type="List" default="ec.service.sync().name('org.moqui.impl.ImageServices.get#ImageReaderMIMETypes').call()?.imageReaderMIMETypes" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyContentId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <if condition="contentFile != null &amp;&amp; !fileMimeTypeList.contains(contentFile.getContentType())">
                <!-- see: https://www.javacodeexamples.com/solution-java-util-regex-patternsyntaxexception-dangling-meta-character-near-index-0/3446 for why not split('+') and is split('\\+') -->
                <!-- see: https://freemarker.apache.org/docs/dgui_misc_autoescaping.html for why not split('\\+') and is split('\\\\+') -->
                <return error="true" message="The file type you used: ${contentFile.getContentType().split('/')[1].split('\\\\+')[0] } is not supported. Please upload a ${fileMimeTypeList.collect{ fileMimeTypeList.indexOf(it) &lt; fileMimeTypeList.size() -1 ? it.split('/')[1].split('\\\\+')[0] : 'or ' + it.split('/')[1].split('\\\\+')[0] }.join(', ')} file format."/>
            </if>
            <if condition="!defaultFileName &amp;&amp; !defaultFileRenderLocation &amp;&amp; contentFile == null"><return message="File not uploaded"/></if>

            <!-- TODO: Handle contentFile uploads with mime types that aren't supported -->
            <if condition="org.moqui.resource.ResourceReference.isTextFilename(contentFile?.getName())"><then>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
            </then><else>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.large.root') ?: 'dbresource://mantle/content'"/>
            </else></if>

            <entity-find-count entity-name="mantle.party.PartyContent" count-field="pcCount">
                <econdition field-name="partyId"/>
                <econdition field-name="contentLocation" operator="is-not-null"/>
                <econdition field-name="partyContentTypeEnumId" value="PcntPostImageSmall"/>
            </entity-find-count>
            <if condition="pcCount &gt;= 12"><return error="true" message="Cannot upload more than 12 Posts"/></if>

            <set field="fileNameNoExtension" from="contentFile.getName().take(contentFile.getName().lastIndexOf('.'))"/>

            <!-- TODO: Use checksum from original to check for duplicates. -->
<!--            <entity-find entity-name="mantle.party.PartyContent" list="pcDuplicateList">-->
<!--                <econdition field-name="partyId"/>-->
<!--                <econdition field-name="partyContentTypeEnumId"/>-->
<!--                <econdition field-name="contentLocation" operator="like" value="${contentRoot}/party/${partyId}/content_%/${fileNameNoExtension}_Original.${outputImageFormat}" ignore-if-empty="true"/>-->
<!--                <order-by field-name="-contentDate"/></entity-find>-->
<!--            <set field="partyContentId" from="pcDuplicateList?.getFirst()?.partyContentId"/>-->
<!--            <if condition="!partyContentId &amp;&amp; pcDuplicateList?.size() == 0">-->


            <set field="Original" type="NewMap"/><set field="contentLocationOriginal"/>
            <set field="Large" type="NewMap"/><set field="contentLocationLarge"/>
            <set field="Medium" type="NewMap"/><set field="contentLocationMedium"/>
            <set field="Small" type="NewMap"/><set field="contentLocationSmall"/>
            <set field="Thumbnail" type="NewMap"/><set field="contentLocationThumbnail"/>

            <if condition="saveOriginal"><service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeOriginal]" out-map="Original"/><set field="contentLocationOriginal" value="${contentRoot}/party/${partyId}/content_${Original.partyContentId}/${fileNameNoExtension}_Original.${outputImageFormat}"/></if>
            <if condition="saveLarge"><service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeLarge]" out-map="Large"/><set field="contentLocationLarge" value="${contentRoot}/party/${partyId}/content_${Large.partyContentId}/${fileNameNoExtension}_Large.${outputImageFormat}"/></if>
            <if condition="saveMedium"><service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeMedium]" out-map="Medium"/><set field="contentLocationMedium" value="${contentRoot}/party/${partyId}/content_${Medium.partyContentId}/${fileNameNoExtension}_Medium.${outputImageFormat}"/></if>
            <if condition="saveSmall"><service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeSmall]" out-map="Small"/><set field="contentLocationSmall" value="${contentRoot}/party/${partyId}/content_${Small.partyContentId}/${fileNameNoExtension}_Small.${outputImageFormat}"/></if>
            <if condition="saveThumbnail"><service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeThumbnail]" out-map="Thumbnail"/><set field="contentLocationThumbnail" value="${contentRoot}/party/${partyId}/content_${Thumbnail.partyContentId}/${fileNameNoExtension}_Thumbnail.${outputImageFormat}"/></if>

<!--            </if>-->

<!--            <set field="inputImage" from="contentFile?.getStoreLocation()"/>-->
<!--            <script>import java.nio.file.Files</script>-->
<!--            <if condition="inputImage"><then>-->
<!--                <log level="warn" message="inputImage?.getParent() ${inputImage?.getParent()}"/>-->
<!--                <log level="warn" message="inputImage?.getParent() ${inputImage?.getParent()}"/>-->
<!--                <log level="warn" message="inputImage?.getPath() ${inputImage?.getPath()}"/>-->
<!--                <log level="warn" message="contentFile?.getContentType() ${contentFile?.getContentType()}"/>-->
<!--                <log level="warn" message="Files.probeContentType(inputImage?.toPath()) ${Files.probeContentType(inputImage?.toPath())}"/>-->
<!--                <log level="warn" message="Files.size(inputImage?.toPath()) ${Files.size(inputImage?.toPath())}"/>-->
<!--            </then><else>-->
<!--                <log level="warn" message="inputImage in memory"/>-->
<!--            </else></if>-->
<!--            <log level="warn" message="ec.resource.getLocationReference(contentLocationOriginal).getSize() ${ec.resource.getLocationReference(contentLocationOriginal).getSize()}"/>-->

<!--            <log level="warn" message="context.toString() ${context.toString()}"/>-->

            <service-call name="org.moqui.impl.ImageServices.convert#Image" in-map="[
                inputImageStream:contentFile.getInputStream(),
                outputImageFormat:outputImageFormat,
                outputResourceReferenceOriginal:ec.resource.getLocationReference(contentLocationOriginal),
                outputResourceReferenceLarge:ec.resource.getLocationReference(contentLocationLarge),
                outputResourceReferenceMedium:ec.resource.getLocationReference(contentLocationMedium),
                outputResourceReferenceSmall:ec.resource.getLocationReference(contentLocationSmall),
                outputResourceReferenceThumbnail:ec.resource.getLocationReference(contentLocationThumbnail),
            ]" out-map="context"/>

<!--            <log level="warn" message="post context.toString() ${context.toString()}"/>-->

            <if condition="saveOriginal"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Original.partyContentId, contentLocation:contentLocationOriginal, contentDate:ec.user.nowTimestamp]"/></if>
            <if condition="saveLarge"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Large.partyContentId, contentLocation:contentLocationLarge, contentDate:ec.user.nowTimestamp]"/></if>
            <if condition="saveMedium"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Medium.partyContentId, contentLocation:contentLocationMedium, contentDate:ec.user.nowTimestamp]"/></if>
            <if condition="saveSmall"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Small.partyContentId, contentLocation:contentLocationSmall, contentDate:ec.user.nowTimestamp]"/></if>
            <if condition="saveThumbnail"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Thumbnail.partyContentId, contentLocation:contentLocationThumbnail, contentDate:ec.user.nowTimestamp]"/></if>
        </actions>
    </service>

    <service verb="check" noun="AccountEdit" authz-action="view">
        <in-parameters>
            <parameter name="partyId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
        </out-parameters>
        <actions>
            <entity-find-count entity-name="mantle.party.PartyFromAndToRelationship" count-field="pfatrCount" cache="true">
                <econdition field-name="toPartyId" from="partyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtManager"/>
                <econdition field-name="fromPartyId" from="ec.user.userAccount.partyId"/>
                <date-filter/></entity-find-count>

            <if condition="pfatrCount == null || pfatrCount == 0"><return type="danger" error="true" message="No Party found with id ${partyId}"/></if>
        </actions>
    </service>

    <service verb="check" noun="ProjectView" authz-action="view">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="workEffortId"/>
        </out-parameters>
        <actions>
            <entity-find-count entity-name="mantle.work.effort.WorkEffortDetailAndPartyDetailWithRole" count-field="wfdapdwfCount" cache="true">
                <econdition field-name="partyRoleTypeId" operator="in" from="['ClientManager']"/>
                <econdition field-name="workEffortTypeEnumId" value="WetProject"/>
                <econdition field-name="visibilityEnumId" value="WevAllUsers"/>
                <date-filter/></entity-find-count>

            <if condition="wfdapdwfCount == null || wfdapdwfCount == 0"><return type="danger" error="true" message="No Project found with id ${workEffortId}"/></if>
        </actions>
    </service>

    <service verb="update" noun="Account">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="pseudoId"/>
            <parameter name="bio"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
            <parameter name="pseudoId"/>
            <parameter name="partyContentId"/>
        </out-parameters>
        <actions>
<!--            <service-call name="resistmanagement.ProfileServices.check#AccountEdit" in-map="[partyId:partyId]"/>-->

<!--            <log level="warn" message="update#Account pseudoId ${pseudoId}"/>-->
            <if condition="pseudoId">
                <!-- no special characters, no spaces, all lowercase, max 30 characters -->
                <set field="pseudoId" from="pseudoId.toLowerCase().replaceAll('[^a-z]+', '')"/>
                <if condition="pseudoId.length() &gt; 30"><return type="info" error="true" message="Profile name cannot be above 30 characters. It is currently ${pseudoId.length()} characters; lease shorten it."/></if>

                <!-- pseudoId is intended to be unique. Check for existing pseudoId with same characters. -->
                <entity-find-one entity-name="mantle.party.Party" value-field="party" auto-field-map="[partyId:partyId]"/>
                <if condition="party != null &amp;&amp; party.pseudoId != pseudoId"><then>
                    <entity-find-count entity-name="mantle.party.Party" count-field="partyCount">
                        <econdition field-name="pseudoId"/></entity-find-count>
                    <if condition="partyCount &gt; 0"><return type="info" error="true" message="Profile name ${pseudoId} is not available. Please choose another."/></if>
                </then><else>
                    <service-call name="update#mantle.party.Party" in-map="[partyId:partyId, pseudoId:pseudoId]" out-map="outMap"/>
                </else></if>

<!--                <log level="warn" message="update#Account pseudoId ${pseudoId}"/>-->
<!--                <log level="warn" message="update#Account outMap.pseudoId ${outMap.pseudoId}"/>-->
            </if>
            <if condition="bio">
                <entity-find entity-name="mantle.party.PartyContent" list="partyContentList">
                    <econdition field-name="partyId"/>
                    <econdition field-name="partyContentTypeEnumId" value="PcntBio"/>
                    <order-by field-name="-contentDate"/></entity-find>
                <if condition="partyContentList"><then>
<!--                    <log level="warn" message="true partyContentList ${partyContentList}"/>-->
                    <service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:partyContentList.getFirst().partyContentId, description:bio]" out-map="context"/>
                </then><else>
<!--                    <log level="warn" message="false partyContentList ${partyContentList}"/>-->
                    <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:'PcntBio', description:bio]" out-map="context"/>
                </else></if>
            </if>
        </actions>
    </service>

    <service verb="create" noun="PersonProfile">
        <description>
            This service makes sure that the caller can't set the fromPartyId to not themselves
        </description>
        <in-parameters>
            <parameter name="pseudoId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ProfileServices.create#PersonProfileInternal" in-map="[pseudoId:pseudoId]" out-map="context"/>
        </actions>
    </service>


    <service verb="create" noun="PersonProfileInternal">
        <in-parameters>
            <parameter name="pseudoId" required="true"/>
            <parameter name="fromPartyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="fromDate" required="true" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
        </out-parameters>
        <actions>
            <!-- fromPartyId required -->
            <if condition="fromPartyId == null || !fromPartyId">
                <log level="warn" message="Must be logged in to create Profile."/>
                <return/></if>

            <!-- no special characters, no spaces, all lowercase, max 30 characters -->
            <set field="pseudoId" from="pseudoId.toLowerCase().replaceAll('[^a-z0-9]+', '')"/>
            <if condition="pseudoId.length() &gt; 30"><return type="info" error="true" message="Profile name cannot be above 30 characters. It is currently ${pseudoId.length()} characters; lease shorten it."/></if>

            <!-- pseudoId is intended to be unique. Check for existing pseudoId with same characters. -->
            <entity-find-count entity-name="mantle.party.Party" count-field="partyCount">
                <econdition field-name="pseudoId"/></entity-find-count>
            <if condition="partyCount &gt; 0"><return type="info" error="true" message="Profile name ${pseudoId} is not available. Please choose another."/></if>

            <service-call name="create#mantle.party.Party" in-map="[pseudoId:pseudoId, partyTypeEnumId:'PtyPerson']" out-map="context"/>
            <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId, roleTypeId:'Customer']"/>
            <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId, roleTypeId:'ClientManager']"/>
            <service-call name="create#mantle.party.PartyRelationship" in-map="[relationshipTypeEnumId:'PrtManager',
                fromPartyId:fromPartyId, fromRoleTypeId:'Administrator', toPartyId:partyId, toRoleTypeId:'ClientManager',
                fromDate:fromDate]"/>
            <service-call name="resistmanagement.ProfileServices.upload#ProfilePictureAttachment" in-map="[partyId:partyId]"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfile">
        <in-parameters>
            <parameter name="emplPositionClassId" required="true"/>
            <parameter name="partyId" required="true"/>
            <parameter name="fromDate"/>
            <auto-parameters entity-name="mantle.humanres.position.EmplPositionClassParty" include="nonpk"/>
        </in-parameters>
        <out-parameters>
            <auto-parameters entity-name="mantle.humanres.position.EmplPositionClassParty" include="pk"/>
        </out-parameters>
        <actions>
            <!-- If party is not a talent, make them a talent. -->
            <entity-find-count entity-name="mantle.party.PartyRole" count-field="talentRoleCount">
                <econdition field-name="partyId"/><econdition field-name="roleTypeId" value="Talent"/></entity-find-count>

            <if condition="talentRoleCount == 0">
                <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId, roleTypeId:'Supplier']"/>
                <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId, roleTypeId:'Talent']"/>
                <service-call name="create#mantle.party.PartyRelationship" in-map="[relationshipTypeEnumId:'PrtManager',
                    fromPartyId:ec.user.userAccount.partyId, fromRoleTypeId:'Administrator', toPartyId:partyId, toRoleTypeId:'Talent',
                    fromDate:ec.user.nowTimestamp]"/>
            </if>

            <if condition="!fromDate">
                <entity-find entity-name="mantle.humanres.position.EmplPositionClassParty" list="epcpList">
                    <econdition field-name="emplPositionClassId"/>
                    <econdition field-name="partyId"/>
                    <date-filter/><order-by field-name="-fromDate"/></entity-find>
                <set field="fromDate" from="epcpList?.getFirst()?.fromDate ?: ec.user.nowTimestamp"/>
            </if>
            <service-call name="store#mantle.humanres.position.EmplPositionClassParty" in-map="context" out-map="context"/>
        </actions>
    </service>

</services>
