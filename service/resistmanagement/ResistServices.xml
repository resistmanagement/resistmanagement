<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">
    <!--                                -->
    <!-- Services for Resist Management -->
    <!--                                -->
    <!--
    All of these services should throw errors the user can understand, and log errors that an admin / developer can understand.
    -->

    <!-- Permission Services -->
    <!--
    Permissions Services are used in screens, services, and other components to determine if a user is allowed to perform an action.
    They should be used whenever content from the client is untrusted, such as when a user is allowed to submit data about themselves
    to the server. They are intended to be as efficient so that they can be used frequently without a significant performance impact.

    These services will need to be refactored when permissions are given to a party to control another profile's data who isn't the owner.
    -->
    <service verb="check" noun="AccountView" authz-action="view">
        <in-parameters>
            <parameter name="partyId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="allowed" default="false"/>
        </out-parameters>
        <actions>
            <set field="allowed" from="false"/>
            <if condition="!ec.user.userAccount?.partyId"><return/></if>

            <!-- If party can edit it, allow viewing of content -->
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="checkAccountEdit"/>
            <if condition="checkAccountEdit?.allowed"><set field="allowed" from="true"/><return/></if>

            <!-- This checks the settings of a party that is a profile (because all client are how we determine if a party is a profile)
            and whether or not the profile has visibility settings to all users.

            If a party is a client manager, with a PartySetting of PartyVisibility set to PtyAllUsers or not set and
            default is PtyAllUsers, allow viewing of account.-->
            <entity-find-count entity-name="mantle.party.PartyDetailAndRoleAndSetting" count-field="pdrsCount" distinct="true">
                <econdition field-name="partyId"/>
                <econdition field-name="roleTypeId" value="ClientManager"/>
                <econdition field-name="partySettingTypeId" value="PartyVisibility"/>
                <econditions combine="or">
                    <econdition field-name="settingValue" value="PtyAllUsers"/>
                    <econditions combine="and">
                        <econdition field-name="settingValue" operator="is-null"/>
                        <econdition field-name="defaultValue" value="PtyAllUsers"/>
                    </econditions>
                </econditions>
            </entity-find-count>

            <if condition="pdrsCount != null &amp;&amp; pdrsCount &gt; 0"><set field="allowed" from="true"/><return/></if>
        </actions>
    </service>

    <service verb="check" noun="AccountEdit" authz-action="view">
        <in-parameters>
            <parameter name="partyId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="allowed" default="false"/>
        </out-parameters>
        <actions>
            <set field="allowed" from="false"/>
            <if condition="!ec.user.userAccount?.partyId"><return/></if>

            <!-- Allow party to edit itself -->
            <if condition="partyId == ec.user.userAccount?.partyId"><set field="allowed" from="true"/><return/></if>

            <!-- Allow party to edit a profile if they have a manager relationship from the currently logged in user. -->
            <entity-find-count entity-name="mantle.party.PartyFromAndToRelationship" count-field="pfatrCount">
                <econdition field-name="toPartyId" from="partyId"/>
                <econdition field-name="relationshipTypeEnumId" value="PrtManager"/>
                <econdition field-name="toRoleTypeId" value="ClientManager"/>
                <econdition field-name="fromPartyId" from="ec.user.userAccount?.partyId"/>
                <date-filter/></entity-find-count>

            <if condition="pfatrCount != null &amp;&amp; pfatrCount &gt; 0"><set field="allowed" from="true"/><return/></if>
        </actions>
    </service>

    <service verb="check" noun="ProjectView" authz-action="view">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="allowed" default="false"/>
        </out-parameters>
        <actions>
            <set field="allowed" from="false"/>
            <if condition="!ec.user.userAccount?.partyId"><return/></if>

            <entity-find-count entity-name="mantle.work.effort.WorkEffortDetailPartyWithRoleAndFromToRelationshipWithEmplPositionApplicationWithCommunicationEventContent" count-field="projectViewCount" distinct="true">
                <econdition field-name="effortPartyWorkEffortId" from="workEffortId"/>
                <econdition field-name="effortWorkEffortTypeEnumId" value="WetProject"/>
                <econdition field-name="effortPurposeEnumId" value="WepPrResistProject"/>

                <!-- Conditions for visibility check -->
                <econdition field-name="relationshipToRoleTypeId" value="ClientManager"/>
                <econdition field-name="relationshipRelationshipTypeEnumId" value="PrtManager"/>
                <econdition field-name="toRoleRoleTypeId" value="ClientManager"/>
                <econditions combine="or">
                    <econdition field-name="effortVisibilityEnumId" value="WevAllUsers"/>
                    <econdition field-name="relationshipFromPartyId" from="ec.user.userAccount?.partyId"/></econditions>
                <date-filter from-field-name="effortPartyFromDate" thru-field-name="effortPartyThruDate"/>
                <date-filter from-field-name="relationshipFromDate" thru-field-name="relationshipThruDate"/>
                <select-field field-name="effortWorkEffortId"/>
            </entity-find-count>

            <if condition="projectViewCount != null &amp;&amp; projectViewCount &gt;= 1"><set field="allowed" from="true"/></if>
        </actions>
    </service>

    <service verb="check" noun="ProjectEdit" authz-action="view">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="allowed" default="false"/>
        </out-parameters>
        <actions>
            <set field="allowed" from="false"/>
            <if condition="!ec.user.userAccount?.partyId"><return/></if>

            <entity-find-count entity-name="mantle.work.effort.WorkEffortDetailPartyWithRoleAndFromToRelationshipWithEmplPositionApplicationWithCommunicationEventContent" count-field="projectEditCount">
                <econdition field-name="effortPartyWorkEffortId" from="workEffortId"/>
                <econdition field-name="effortWorkEffortTypeEnumId" value="WetProject"/>
                <econdition field-name="effortPurposeEnumId" value="WepPrResistProject"/>

                <!-- Conditions for visibility check -->
                <econdition field-name="effortPartyRoleTypeId" value="Manager"/>
                <econdition field-name="relationshipToRoleTypeId" value="ClientManager"/>
                <econdition field-name="relationshipRelationshipTypeEnumId" value="PrtManager"/>
                <econdition field-name="toRoleRoleTypeId" value="ClientManager"/>
                <econdition field-name="relationshipFromPartyId" from="ec.user.userAccount?.partyId"/>
                <date-filter from-field-name="effortPartyFromDate" thru-field-name="effortPartyThruDate"/>
                <date-filter from-field-name="relationshipFromDate" thru-field-name="relationshipThruDate"/>
                <select-field field-name="effortPartyWorkEffortId"/>
            </entity-find-count>

            <if condition="projectEditCount != null &amp;&amp; projectEditCount == 1"><set field="allowed" from="true"/></if>
        </actions>
    </service>

    <service verb="check" noun="ProjectPositionView" authz-action="view">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="allowed" default="false"/>
        </out-parameters>
        <actions>
            <set field="allowed" from="false"/>
            <if condition="!ec.user.userAccount?.partyId"><return/></if>

            <service-call name="resistmanagement.ResistServices.check#ProjectEdit" in-map="[workEffortId:workEffortId]" out-map="projectEdit"/>
            <if condition="projectEdit?.allowed == true"><set field="allowed" from="true"/><return/></if>

            <service-call name="resistmanagement.ResistServices.check#ProjectView" in-map="[workEffortId:workEffortId]" out-map="projectView"/>
            <if condition="!projectView?.allowed"><return/></if>

            <!-- Only show the project position if the WorkEffort has more than one projectPosition. -->
            <entity-find-count entity-name="mantle.work.effort.WorkEffortEmplPositionDetail" count-field="projectPositionCount">
                <econdition field-name="effortWorkEffortId" from="workEffortId"/>
                <select-field field-name="effortWorkEffortId,positionEmplPositionId"/>
            </entity-find-count>

            <if condition="projectPositionCount != null &amp;&amp; projectPositionCount &gt; 0"><set field="allowed" from="true"/></if>
        </actions>
    </service>

    <service verb="check" noun="AccountPartyContentView" authz-action="view" authenticate="anonymous-view">
        <in-parameters>
            <parameter name="partyContentId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="allowed" default="false"/>
        </out-parameters>
        <actions>
            <set field="allowed" from="false"/>
            <if condition="!ec.user.userAccount?.partyId"><return/></if>

            <!-- If party can edit it, allow viewing of content -->
            <entity-find-one entity-name="mantle.party.PartyContent" value-field="partyContent" auto-field-map="[partyContentId:partyContentId]">
                <select-field field-name="partyId"/></entity-find-one>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyContent.partyId]" out-map="checkAccountEdit"/>
            <if condition="checkAccountEdit?.allowed"><set field="allowed" from="true"/><return/></if>

            <entity-find-count entity-name="mantle.party.PartyDetailAndRoleAndContentAndSetting" count-field="pdrcsCount" distinct="true">
                <econdition field-name="partyContentId"/>
                <econdition field-name="roleTypeId" value="ClientManager"/>
                <econdition field-name="partySettingTypeId" value="PartyVisibility"/>
                <econditions combine="or">
                    <econdition field-name="settingValue" value="PtyAllUsers"/>
                    <econditions combine="and">
                        <econdition field-name="settingValue" operator="is-null"/>
                        <econdition field-name="defaultValue" value="PtyAllUsers"/>
                    </econditions>
                    <econdition field-name="partyContentTypeEnumId" value="PcntPrimaryImage"/>
                </econditions>
            </entity-find-count>

            <if condition="pdrcsCount != null &amp;&amp; pdrcsCount &gt; 0"><set field="allowed" from="true"/></if>
        </actions>
    </service>

    <service verb="check" noun="AccountCommEventContentView" authz-action="view">
        <in-parameters>
            <parameter name="communicationEventContentId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="allowed" default="false"/>
        </out-parameters>
        <actions>
            <set field="allowed" from="false"/>
            <if condition="!ec.user.userAccount?.partyId"><return/></if>

            <!-- See if the content exists of the right type and communication event type -->
            <entity-find entity-name="mantle.party.communication.CommunicationEventAndContent" list="communicationEventAndContentList" limit="1">
                <econdition field-name="communicationEventContentId"/>
                <econdition field-name="communicationEventTypeId" value="Post"/>
                <econdition field-name="contentTypeEnumId" operator="in" value="CmctImageOriginal,CmctImageMedium,CmctImageSmall"/>
                <select-field field-name="fromPartyId"/></entity-find>
            <set field="communicationEventAndContent" from="communicationEventAndContentList?.getFirst()"/>
            <if condition="!communicationEventAndContent"><return error="true" type="danger" message="No content found."/></if>

            <!-- If party can edit it, allow viewing of content -->
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:communicationEventAndContent.fromPartyId]" out-map="checkAccountEdit"/>
            <if condition="checkAccountEdit?.allowed == true"><set field="allowed" from="true"/><return/></if>

            <service-call name="resistmanagement.ResistServices.check#AccountView" in-map="[partyId:communicationEventAndContent.fromPartyId]" out-map="checkAccountView"/>
            <if condition="checkAccountView?.allowed"><set field="allowed" from="true"/></if>

        </actions>
    </service>

    <service verb="check" noun="ProjectCommEventContentView" authz-action="view">
        <in-parameters>
            <parameter name="communicationEventContentId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="allowed" default="false" required="true"/>
        </out-parameters>
        <actions>
            <set field="allowed" from="false"/>
            <if condition="!ec.user.userAccount?.partyId"><return/></if>

            <!-- See if the content exists of the right type and project communication event type -->
            <entity-find entity-name="mantle.party.communication.CommunicationEventAndContentWithWorkEffort" list="communicationEventAndContentList">
                <econdition field-name="eventContentCommunicationEventContentId" from="communicationEventContentId"/>
                <econdition field-name="eventCommunicationEventTypeId" value="Post"/>
                <econdition field-name="eventContentContentTypeEnumId" operator="in" value="CmctImageOriginal,CmctImageMedium,CmctImageSmall"/>
                <select-field field-name="effortEventWorkEffortId"/></entity-find>
            <set field="communicationEventAndContent" from="communicationEventAndContentList?.getFirst()"/>
            <if condition="!communicationEventAndContent"><return error="true" type="danger" message="No content found."/></if>

            <!-- If party can edit it, allow viewing of content -->
            <service-call name="resistmanagement.ResistServices.check#ProjectEdit" in-map="[workEffortId:communicationEventAndContent.effortEventWorkEffortId]" out-map="checkProjectEdit"/>
            <if condition="checkProjectEdit?.allowed == true"><set field="allowed" from="true"/><return/></if>

            <service-call name="resistmanagement.ResistServices.check#ProjectView" in-map="[workEffortId:communicationEventAndContent.effortEventWorkEffortId]" out-map="checkProjectView"/>
            <if condition="checkProjectView?.allowed"><set field="allowed" from="true"/></if>
        </actions>
    </service>
    <!-- End Permission Services -->

    <!-- Talent screen services -->
    <service verb="store" noun="PartyDimension">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="uomDimensionTypeId" required="true"/>
            <parameter name="value"/>
            <parameter name="uomId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
            <parameter name="uomDimensionTypeId"/>
            <parameter name="dimensionDate"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="context"/>
            <if condition="!allowed"><return type="danger" error="true" message="Not allowed to edit this account"/></if>

            <service-call name="store#mantle.party.PartyDimension" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="PartyClassificationAppl">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="classificationTypeEnumId" required="true"/>
            <parameter name="partyClassificationId"/>
            <parameter name="fromDate" required="true" default="ec.user.nowTimestamp"/>
            <auto-parameters entity-name="mantle.party.PartyClassificationAppl" include="nonpk"/>
        </in-parameters>
        <out-parameters>
            <auto-parameters entity-name="mantle.party.PartyClassificationAppl"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="context"/>
            <if condition="!allowed"><return type="danger" error="true" message="Not allowed to edit this account"/></if>

            <entity-find entity-name="mantle.party.PartyClassificationAndAppl" list="pcapList">
                <econdition field-name="partyId"/><econdition field-name="classificationTypeEnumId"/>
                <date-filter/><order-by field-name="-thruDate,-fromDate"/></entity-find>
            <iterate list="pcapList" entry="pcap">
                <set field="pcapOut" from="pcap"/><set field="pcapOut.thruDate" from="ec.user.nowTimestamp"/>
                <service-call name="update#mantle.party.PartyClassificationAppl" in-map="pcapOut"/></iterate>

            <if condition="partyId &amp;&amp; partyClassificationId &amp;&amp; fromDate">
                <service-call name="store#mantle.party.PartyClassificationAppl" in-map="context + [thruDate:null]" out-map="outContext"/>
            </if>
        </actions>
    </service>

    <service verb="set" noun="PartySkill">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="emplPositionClassId" required="true"/>
            <parameter name="skillTypeEnumIdList" type="List"/>
        </in-parameters>
        <out-parameters>
            <parameter name="skillTypeEnumIdList"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="context"/>
            <if condition="!allowed"><return type="danger" error="true" message="Not allowed to edit this account"/></if>

            <entity-find entity-name="mantle.humanres.position.EmplPositionClassSkill" list="epcsList">
                <econdition field-name="emplPositionClassId"/></entity-find>
            <entity-find entity-name="mantle.humanres.ability.PartySkill" list="psList">
                <econdition field-name="skillTypeEnumId" operator="in" from="epcsList.skillTypeEnumId"/>
                <econdition field-name="partyId"/></entity-find>

            <iterate list="epcsList" entry="epcs">
                <if condition="skillTypeEnumIdList?.contains(epcs.skillTypeEnumId) &amp;&amp; !psList.skillTypeEnumId.contains(epcs.skillTypeEnumId)"><then>
                    <service-call name="create#mantle.humanres.ability.PartySkill" in-map="[partyId:partyId, skillTypeEnumId:epcs.skillTypeEnumId]"/>
                </then><else-if condition="!skillTypeEnumIdList?.contains(epcs.skillTypeEnumId) &amp;&amp; psList.skillTypeEnumId.contains(epcs.skillTypeEnumId)">
                    <service-call name="delete#mantle.humanres.ability.PartySkill" in-map="[partyId:partyId, skillTypeEnumId:epcs.skillTypeEnumId]"/>
                </else-if><else-if condition="skillTypeEnumIdList?.contains(epcs.skillTypeEnumId) &amp;&amp; psList.skillTypeEnumId.contains(epcs.skillTypeEnumId)">
                </else-if><else-if condition="!skillTypeEnumIdList?.contains(epcs.skillTypeEnumId) &amp;&amp; !psList.skillTypeEnumId.contains(epcs.skillTypeEnumId)">
                </else-if></if>
            </iterate>
        </actions>
    </service>

    <service verb="store" noun="TalentProfile">
        <in-parameters>
            <parameter name="emplPositionClassId" required="true"/>
            <parameter name="partyId" required="true"/>
            <parameter name="fromDate"/>
            <auto-parameters entity-name="mantle.humanres.position.EmplPositionClassParty" include="nonpk"/>
        </in-parameters>
        <out-parameters>
            <auto-parameters entity-name="mantle.humanres.position.EmplPositionClassParty" include="pk"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="context"/>
            <if condition="!allowed"><return type="danger" error="true" message="Not allowed to edit this account"/></if>

            <!-- If party is not a talent, make them a talent. -->
            <entity-find-count entity-name="mantle.party.PartyRole" count-field="talentRoleCount">
                <econdition field-name="partyId"/><econdition field-name="roleTypeId" value="Talent"/></entity-find-count>
            <if condition="talentRoleCount == 0">
                <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId, roleTypeId:'Supplier']"/>
                <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId, roleTypeId:'Talent']"/>
                <service-call name="create#mantle.party.PartyRelationship" in-map="[relationshipTypeEnumId:'PrtManager',
                    fromPartyId:ec.user.userAccount.partyId, fromRoleTypeId:'Administrator', toPartyId:partyId, toRoleTypeId:'Talent',
                    fromDate:ec.user.nowTimestamp]"/>
            </if>

            <if condition="!fromDate">
                <entity-find entity-name="mantle.humanres.position.EmplPositionClassParty" list="epcpList">
                    <econdition field-name="emplPositionClassId"/>
                    <econdition field-name="partyId"/>
                    <date-filter/><order-by field-name="-fromDate"/></entity-find>
                <set field="fromDate" from="epcpList?.getFirst()?.fromDate ?: ec.user.nowTimestamp"/>
            </if>
            <service-call name="store#mantle.humanres.position.EmplPositionClassParty" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="delete" noun="TalentProfile">
        <in-parameters>
            <auto-parameters entity-name="mantle.humanres.position.EmplPositionClassParty" include="pk" required="true"/>
        </in-parameters>
        <out-parameters>
            <auto-parameters entity-name="mantle.humanres.position.EmplPositionClassParty" include="pk"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="context"/>
            <if condition="!allowed"><return type="danger" error="true" message="Not allowed to edit this account"/></if>

            <service-call name="delete#mantle.humanres.position.EmplPositionClassParty" in-map="context" out-map="context"/>
        </actions>
    </service>
    <!-- End Talent screen services -->


    <service verb="update" noun="Account">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="settingValue" required="true"/>
            <parameter name="pseudoId"/>
            <parameter name="bio"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
            <parameter name="pseudoId"/>
            <parameter name="partyContentId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="context"/>
            <if condition="!allowed"><return type="danger" error="true" message="Not allowed to edit this account"/></if>

            <if condition="pseudoId">
                <!-- no special characters, no spaces, all lowercase, max 30 characters -->
                <set field="pseudoId" from="pseudoId.toLowerCase().replaceAll('[^a-z]+', '')"/>
                <if condition="pseudoId.length() &gt; 30"><return type="info" error="true" message="Profile name cannot be above 30 characters. It is currently ${pseudoId.length()} characters; please shorten it."/></if>

                <!-- pseudoId is intended to be unique. Check for existing pseudoId with same characters. -->
                <entity-find-one entity-name="mantle.party.Party" value-field="party" auto-field-map="[partyId:partyId]"/>
                <if condition="party != null &amp;&amp; party.pseudoId != pseudoId"><then>
                    <entity-find-count entity-name="mantle.party.Party" count-field="partyCount">
                        <econdition field-name="pseudoId" ignore-case="true"/></entity-find-count>
                    <if condition="partyCount &gt; 0"><return type="info" error="true" message="Profile name ${pseudoId} is not available. Please choose another."/></if>
                </then><else>
                    <service-call name="update#mantle.party.Party" in-map="[partyId:partyId, pseudoId:pseudoId]" out-map="outMap"/>
                </else></if>

            </if>
            <if condition="bio">
                <entity-find entity-name="mantle.party.PartyContent" list="partyContentList">
                    <econdition field-name="partyId"/>
                    <econdition field-name="partyContentTypeEnumId" value="PcntBio"/>
                    <order-by field-name="-contentDate"/></entity-find>
                <if condition="partyContentList"><then>
                    <service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:partyContentList.getFirst().partyContentId, description:bio]" out-map="context"/>
                </then><else>
                    <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:'PcntBio', description:bio]" out-map="context"/>
                </else></if>
            </if>
            <service-call name="store#mantle.party.PartySetting" in-map="[partyId:partyId, partySettingTypeId:'PartyVisibility', settingValue:settingValue]" out-map="context"/>
        </actions>
    </service>

    <!-- Profile Services -->
    <service verb="create" noun="PersonProfile">
        <description>
            This service makes sure that the caller can't set the fromPartyId to not themselves
        </description>
        <in-parameters>
            <parameter name="pseudoId" required="true"/>
            <parameter name="settingValue" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.create#PersonProfileInternal" in-map="[pseudoId:pseudoId,settingValue:settingValue]" out-map="context"/>
        </actions>
    </service>

    <service verb="count" noun="PartyAccountOwned">
        <in-parameters></in-parameters>
        <out-parameters>
            <parameter name="accountCount"/>
        </out-parameters>
        <actions>
            <entity-find-count entity-name="mantle.party.PartyDetailAndRoleAndContentAndSettingAndRelationshipAndEmplApplication" count-field="accountCount" distinct="true" cache="true">
                <econdition field-name="roleRoleTypeId" value="ClientManager"/>
                <econdition field-name="settingPartySettingTypeId" value="PartyVisibility"/>
                <econdition field-name="contentPartyContentTypeEnumId" value="PcntPrimaryImage"/>
                <econdition field-name="contentContentLocation" operator="is-not-null"/>
                <econdition field-name="relationshipRelationshipTypeEnumId" value="PrtManager"/>
                <econdition field-name="relationshipFromRoleTypeId" value="Administrator"/>
                <econdition field-name="relationshipToRoleTypeId" value="ClientManager"/>
                <econdition field-name="relationshipFromPartyId" from="ec.user.userAccount?.partyId"/>
                <date-filter from-field-name="relationshipFromDate" thru-field-name="relationshipThruDate"/>
                <date-filter from-field-name="effortPartyFromDate" thru-field-name="effortPartyThruDate"/>
            </entity-find-count>
        </actions>
    </service>

    <service verb="create" noun="PersonProfileInternal">
        <description>This exists so that there can be an authz layer for external user and is used for making data loading easier.</description>
        <in-parameters>
            <parameter name="pseudoId" required="true"/>
            <parameter name="settingValue" required="true"/>
            <parameter name="fromPartyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="fromDate" required="true" default="ec.user.nowTimestamp"/>
            <parameter name="partySettingTypeId" required="true" default-value="PartyVisibility"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
            <parameter name="partySettingTypeId"/>
        </out-parameters>
        <actions>
            <!-- fromPartyId required -->
            <if condition="fromPartyId == null || !fromPartyId"><return type="warning" message="Must be logged in to create Profile."/></if>

            <service-call name="resistmanagement.ResistServices.count#PartyAccountOwned" out-map="context"/>
            <if condition="accountCount &gt; 0"><return type="warning" message="Can only create one Account per User."/></if>

            <!-- no special characters, no spaces, all lowercase, max 30 characters -->
            <set field="pseudoId" from="pseudoId.toLowerCase().replaceAll('[^a-zA-Z0-9_.]+', '')"/>
            <if condition="pseudoId.length() &gt; 30"><return type="info" error="true" message="Profile name cannot be above 30 characters. It is currently ${pseudoId.length()} characters; lease shorten it."/></if>

            <!-- pseudoId is intended to be unique. Check for existing pseudoId with same characters. -->
            <entity-find-count entity-name="mantle.party.Party" count-field="partyCount">
                <econdition field-name="pseudoId" ignore-case="true"/></entity-find-count>
            <if condition="partyCount &gt; 0"><return type="info" error="true" message="Profile name ${pseudoId} is not available. Please choose another."/></if>

            <service-call name="create#mantle.party.Party" in-map="[pseudoId:pseudoId, partyTypeEnumId:'PtyPerson']" out-map="context"/>
            <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId, roleTypeId:'Customer']"/>
            <service-call name="create#mantle.party.PartyRole" in-map="[partyId:partyId, roleTypeId:'ClientManager']"/>
            <service-call name="create#mantle.party.PartyRelationship" in-map="[relationshipTypeEnumId:'PrtManager',
                fromPartyId:fromPartyId, fromRoleTypeId:'Administrator', toPartyId:partyId, toRoleTypeId:'ClientManager',
                fromDate:fromDate]"/>
            <service-call name="create#mantle.party.PartySetting" in-map="[partyId:partyId, partySettingTypeId:partySettingTypeId, settingValue:settingValue]" out-map="context"/>
            <service-call name="resistmanagement.ResistServices.upload#ProfilePictureAttachment" in-map="[partyId:partyId]" out-map="context"/>
        </actions>
    </service>
    <!-- Profile Services -->

    <!-- Project Services -->
    <service verb="create" noun="Project">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="ownerPartyId" default="partyId"/>
            <parameter name="workEffortName" required="true"/>
            <parameter name="estimatedStartDate" type="Timestamp" format="yyyy-MM-dd"/>
            <parameter name="visibilityEnumId"/>
            <parameter name="estimatedWorkDuration"/>
            <parameter name="description"/>
            <parameter name="workEffortTypeEnumId" default-value="WetProject"/>
            <parameter name="purposeEnumId" default-value="WepPrResistProject"/>
            <parameter name="statusId" default-value="WeInPlanning"/>

            <parameter name="vendorManagerPartyId" default="partyId"/>

            <parameter name="assignToPartyId" default="ec.user.userAccount.partyId"/>
            <parameter name="assignRoleTypeId" default-value="Assignee"/>
            <parameter name="assignStatusId" default-value="WeptAssigned"/>
        </in-parameters>
        <out-parameters><parameter name="workEffortId"/></out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="AccountEdit"/>
            <if condition="!AccountEdit?.allowed"><return error="true" message="Cannot create Project"/></if>

            <service-call name="mantle.work.ProjectServices.create#Project" in-map="context + [statusFlowId:'ResistProject']" out-map="context"/>
        </actions>
    </service>

    <service verb="update" noun="Project">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="visibilityEnumId"/>
            <parameter name="statusId"/>
            <parameter name="workEffortName"/>
            <parameter name="description"/>
            <parameter name="estimatedStartDate" type="Timestamp" format="yyyy-MM-dd"/>
            <parameter name="estimatedWorkDuration"/>
            <parameter name="purposeEnumId" default-value="WepPrResistProject"/>
        </in-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#ProjectEdit" in-map="[workEffortId:workEffortId]" out-map="projectEdit"/>
            <if condition="!projectEdit?.allowed"><return error="true" message="Cannot update Project"/></if>

            <!-- Added statusFlowId so that when updating project, old project data will be changed to a Resist Project -->
            <service-call name="mantle.work.ProjectServices.update#Project" in-map="context + [statusFlowId:'ResistProject']"/>
        </actions>
    </service>

    <service verb="create" noun="ProjectPosition">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="emplPositionClassId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
            <parameter name="workEffortId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#ProjectEdit" in-map="[workEffortId:workEffortId]" out-map="projectEdit"/>
            <if condition="!projectEdit?.allowed"><return type="danger" error="true" message="Not allowed to edit this project"/></if>

            <!-- Limit one position per class per profile -->
            <entity-find-count entity-name="mantle.work.effort.WorkEffortEmplPositionDetail" count-field="workEffortEmplPositionCount">
                <econdition field-name="effortWorkEffortId" from="workEffortId"/>
                <econdition field-name="positionEmplPositionClassId" from="emplPositionClassId"/></entity-find-count>
            <if condition="workEffortEmplPositionCount &gt; 0"><return type="info" message="Project position already added."/></if>

            <service-call name="create#mantle.humanres.position.EmplPosition" in-map="[emplPositionClassId:emplPositionClassId, statusId:'EmpsActive']" out-map="context"/>
            <service-call name="create#mantle.work.effort.WorkEffortEmplPosition" in-map="[workEffortId:workEffortId, emplPositionId:emplPositionId]" out-map="context"/>
        </actions>
    </service>

    <service verb="update" noun="ProjectPositionStatus">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="emplPositionId" required="true"/>
            <parameter name="statusId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
            <parameter name="workEffortId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#ProjectEdit" in-map="[workEffortId:workEffortId]" out-map="projectEdit"/>
            <if condition="!projectEdit?.allowed"><return type="danger" error="true" message="Not allowed to edit this project position"/></if>

            <entity-find-one entity-name="WorkEffortDetailPartyWithRoleAndFromToRelationshipWithEmplPositionApplication" value-field="emplPosition">
                <field-map field-name="effortWorkEffortId" from="workEffortId"/>
                <field-map field-name="positionEmplPositionId" from="emplPositionId"/>
                <select-field field-name="positionStatusStatusId"/>
            </entity-find-one>

            <!-- Failure condition don't update entry -->
            <if condition="statusId &amp;&amp; emplPosition.positionStatusStatusId &amp;&amp; statusId == emplPosition.positionStatusStatusId">
                <return type="warning" message="Position is already ${emplPosition.positionStatusDescription ?: emplPosition.positionStatusStatusId}"/>
            </if>

            <service-call name="update#mantle.humanres.position.EmplPosition" in-map="[emplPositionId:emplPositionId, statusId:statusId]" out-map="context"/>
        </actions>
    </service>

    <service verb="create" noun="ProjectPositionApplication">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="emplPositionId" required="true"/>
            <parameter name="statusId" required="true"/>
            <parameter name="applyingPartyId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="employmentApplicationId"/>
        </out-parameters>
        <actions>
            <!-- Make sure that statusId is in the allowed values -->
            <if condition="!['EaApplied','EaInvited'].contains(statusId)">
                <entity-find-one entity-name="moqui.basic.StatusItem" value-field="status" auto-field-map="[statusId:statusId,statusTypeId:'EmploymentApplication']"/>
                <return error="true" message="Cannot apply for project with status ${status?.description ?: statusId}"/></if>

            <!-- If statusId is Proposed and cannot edit, throw error; otherwise set to requested -->
            <service-call name="resistmanagement.ResistServices.check#ProjectEdit" in-map="[workEffortId:workEffortId]" out-map="projectEdit"/>
            <if condition="statusId == 'EaInvited' &amp;&amp; !projectEdit.allowed"><return error="true" message="Cannot invite to project position"/></if>

            <!-- If applyingPartyId is not set, use the logged in user to find the account it owns; if there's more than one account allowed, ask for the account party information; if there's no accounts found, have use create an account. -->
            <if condition="!applyingPartyId">
                <entity-find entity-name="mantle.party.PartyToAndRelationship" list="managedAccountRelationshipList">
                    <econdition field-name="fromPartyId" from="ec.user.userAccount.partyId"/>
                    <econdition field-name="relationshipTypeEnumId" value="PrtManager"/>
                    <econdition field-name="toRoleTypeId" value="ClientManager"/>
                    <date-filter/>
                    <select-field field-name="toPartyId"/>
                </entity-find>
                <if condition="managedAccountRelationshipList.size() == 0"><return error="true" message="Please create an account to apply with."/></if>
                <if condition="managedAccountRelationshipList.size() &gt; 1"><return error="true" message="Please select account to apply with."/></if>
                <set field="applyingPartyId" from="managedAccountRelationshipList.getFirst().toPartyId"/>
            </if>

            <entity-find-count entity-name="mantle.humanres.employment.EmploymentApplication" count-field="employmentApplicationCount">
                <econdition field-name="emplPositionId"/>
                <econdition field-name="applyingPartyId"/>
            </entity-find-count>
            <if condition="employmentApplicationCount &gt; 0"><return error="true" type="danger" message="This account has applied, and can't apply again"/></if>

            <service-call name="create#mantle.humanres.employment.EmploymentApplication" in-map="[emplPositionId:emplPositionId,statusId:statusId,referredByEnumId:'EarbPersonal',applicationDate:ec.user.nowTimestamp,applyingPartyId:applyingPartyId]" out-map="context"/>
        </actions>
    </service>

    <service verb="update" noun="ProjectPositionApplicationStatus">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="emplPositionId" required="true"/>
            <parameter name="employmentApplicationId" required="true"/>
            <parameter name="statusId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="statusId"/>
        </out-parameters>
        <actions>
            <!-- Make sure that statusId is in the allowed values -->
            <if condition="!['EaInvited','EaApplied','EaApproved','EaRejected','EaCanceled'].contains(statusId)">
                <return error="true" message="Cannot put project position in status ${statusId}"/></if>

            <!-- Find the employment position -->
            <entity-find entity-name="mantle.work.effort.WorkEffortDetailPartyWithRoleAndFromToRelationshipWithEmplPositionApplication" list="emplPositionList" distinct="true">
                <econdition field-name="effortWorkEffortId" from="workEffortId"/>
                <econdition field-name="positionEmplPositionId" from="emplPositionId"/>
                <econdition field-name="applicationEmploymentApplicationId" from="employmentApplicationId"/>
                <econdition field-name="toRoleRoleTypeId" value="ClientManager"/>
                <select-field field-name="effortWorkEffortId,toRoleRoleTypeId,applicationEmploymentApplicationId,applicationStatusStatusId,applicationApplyingPartyId"/>
            </entity-find>
            <if condition="emplPositionList.size() == 0"><log level="warn" message="Service update#ProjectPositionApplicationStatus's project position not found"/></if>
            <if condition="emplPositionList.size() &gt; 1"><log level="warn" message="Service update#ProjectPositionApplicationStatus's entity find shouldn't return more than one entry from it's query."/></if>
            <set field="emplPosition" from="emplPositionList.getFirst()"/>

            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:emplPosition.applicationApplyingPartyId]" out-map="accountEdit"/>
            <service-call name="resistmanagement.ResistServices.check#ProjectEdit" in-map="[workEffortId:workEffortId]" out-map="projectEdit"/>
            <set field="allowed" from="false"/>
            <!-- Limit the status changes based on the current status -->
            <if condition="statusId == 'EaInvited' &amp;&amp; projectEdit?.allowed &amp;&amp; ['EaRejected'].contains(emplPosition.applicationStatusStatusId)"><set field="allowed" from="true"/></if>
            <if condition="statusId == 'EaApplied' &amp;&amp; accountEdit?.allowed &amp;&amp; ['EaCanceled'].contains(emplPosition.applicationStatusStatusId)"><set field="allowed" from="true"/></if>
            <if condition="statusId == 'EaApproved' &amp;&amp; projectEdit?.allowed &amp;&amp; ['EaApplied'].contains(emplPosition.applicationStatusStatusId) || accountEdit?.allowed &amp;&amp; ['EaInvited'].contains(emplPosition.applicationStatusStatusId)"><set field="allowed" from="true"/></if>
            <if condition="statusId == 'EaRejected' &amp;&amp; projectEdit?.allowed &amp;&amp; ['EaApplied'].contains(emplPosition.applicationStatusStatusId)"><set field="allowed" from="true"/></if>
            <if condition="statusId == 'EaCanceled' &amp;&amp; accountEdit?.allowed &amp;&amp; ['EaInvited'].contains(emplPosition.applicationStatusStatusId)"><set field="allowed" from="true"/></if>

            <if condition="allowed == false"><return type="danger" error="true" message="Not allowed to edit this project position"/></if>

            <if condition="allowed == true">
                <service-call name="update#mantle.humanres.employment.EmploymentApplication" in-map="[employmentApplicationId:employmentApplicationId,statusId:statusId]" out-map="context"/>
                <if condition="statusId == 'EaApproved'">
                    <!-- If party is not a talent, make them a talent, because this action would make them a talent. -->
                    <entity-find-count entity-name="mantle.party.PartyRole" count-field="talentRoleCount">
                        <econdition field-name="partyId" from="emplPosition.applicationApplyingPartyId"/><econdition field-name="roleTypeId" value="Talent"/></entity-find-count>
                    <if condition="talentRoleCount == 0">
                        <service-call name="create#mantle.party.PartyRole" in-map="[partyId:emplPosition.applicationApplyingPartyId, roleTypeId:'Supplier']"/>
                        <service-call name="create#mantle.party.PartyRole" in-map="[partyId:emplPosition.applicationApplyingPartyId, roleTypeId:'Talent']"/>
                        <!-- TODO: Not sure if this is needed or not -->
<!--                        <service-call name="create#mantle.party.PartyRelationship" in-map="[relationshipTypeEnumId:'PrtManager',-->
<!--                            fromPartyId:ec.user.userAccount.partyId, fromRoleTypeId:'Administrator', toPartyId:emplPosition.applicationApplyingPartyId, toRoleTypeId:'Talent',-->
<!--                            fromDate:ec.user.nowTimestamp]"/>-->
                    </if>

                    <!-- Check to see if the party is already a talent on the project -->
                    <entity-find entity-name="mantle.work.effort.WorkEffortParty" list="wepList" limit="1">
                        <date-filter/>
                        <econdition field-name="workEffortId"/>
                        <econdition field-name="partyId" from="emplPosition.applicationApplyingPartyId"/>
                        <econdition field-name="roleTypeId" value="Talent"/>
                        <econdition field-name="emplPositionId"/>
                        <order-by field-name="-fromDate"/>
                    </entity-find>
                    <set field="fromDate" from="ec.user.nowTimestamp"/>
                    <if condition="wepList"><then>
                        <set field="fromDate" from="wepList[0].fromDate"/>
                        <service-call name="update#mantle.work.effort.WorkEffortParty" in-map="[workEffortId:workEffortId,partyId:emplPosition.applicationApplyingPartyId,emplPositionId:emplPositionId,statusId:'WeptAssigned',roleTypeId:'Talent',fromDate:fromDate]"/>
                    </then><else>
                        <service-call name="create#mantle.work.effort.WorkEffortParty" in-map="[workEffortId:workEffortId,partyId:emplPosition.applicationApplyingPartyId,emplPositionId:emplPositionId,statusId:'WeptAssigned',roleTypeId:'Talent',fromDate:fromDate]"/>
                    </else></if>
                </if>
            </if>
        </actions>
    </service>

    <service verb="update" noun="ProjectPartyStatus">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="partyId" required="true"/>
            <parameter name="fromDate" required="true"/>
            <parameter name="statusId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="statusId"/>
        </out-parameters>
        <actions>
            <!-- Make sure that statusId is in the allowed values -->
            <if condition="!['WeptUnassigned','WeptDeclined','WeptAssigned'].contains(statusId)">
                <return error="true" message="Cannot put project party in status ${statusId}"/></if>

            <entity-find-one entity-name="mantle.work.effort.WorkEffortParty" value-field="workEffortParty" auto-field-map="[workEffortId:workEffortId,partyId:partyId,fromDate:fromDate,roleTypeId:'Talent']"/>
            <if condition="!workEffortParty"><return type="warning" message="Service update#ProjectPartyStatus's project party not found"/></if>

            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="accountEdit"/>
            <service-call name="resistmanagement.ResistServices.check#ProjectEdit" in-map="[workEffortId:workEffortId]" out-map="projectEdit"/>
            <set field="allowed" from="false"/>
            <if condition="statusId == 'WeptUnassigned' &amp;&amp; projectEdit?.allowed &amp; workEffortParty.statusId == 'WeptAssigned'"><set field="allowed" from="true"/></if>
            <if condition="statusId == 'WeptDeclined' &amp;&amp; accountEdit?.allowed &amp; workEffortParty.statusId == 'WeptAssigned'"><set field="allowed" from="true"/></if>
            <if condition="statusId == 'WeptAssigned' &amp;&amp; projectEdit?.allowed &amp;&amp; workEffortParty.statusId == 'WeptUnassigned'"><set field="allowed" from="true"/></if>
            <if condition="statusId == 'WeptAssigned' &amp;&amp; accountEdit?.allowed &amp;&amp; workEffortParty.statusId == 'WeptDeclined'"><set field="allowed" from="true"/></if>

            <if condition="allowed == false"><return type="danger" error="true" message="Not allowed to edit this project party"/></if>

            <if condition="allowed == true">
                <service-call name="update#mantle.work.effort.WorkEffortParty" in-map="[workEffortId:workEffortId,partyId:partyId,fromDate:fromDate,roleTypeId:'Talent',statusId:statusId]" out-map="context"/>
            </if>
        </actions>
    </service>
    <!-- End of Project Services -->

    <!-- Notification Services -->
    <service verb="send" noun="DataDocumentChatNotifications" authenticate="false">
        <description>
            Like the 'org.moqui.impl.EntityServices.send#DataDocumentNotifications' but also looks for partyId/fromPartyId/toPartyId
            fields in the DataDocument and looks up their UserAccount.userId values if there are any to notify those users.
        </description>
        <implements service="org.moqui.EntityServices.receive#DataFeed"/>
        <actions>
            <iterate list="documentList" entry="document">
                <entity-find entity-name="mantle.party.PartyRelationship" list="toPartyRelationshipList">
                    <econdition field-name="relationshipTypeEnumId" value="PrtManager"/>
                    <econdition field-name="toRoleTypeId" value="ClientManager"/>
                    <econdition field-name="toPartyId" from="document.toPartyId"/>
                    <date-filter/>
                </entity-find>

                <entity-find entity-name="moqui.security.UserAccount" list="toUserAccountList">
                    <econdition field-name="partyId" operator="in" from="toPartyRelationshipList*.fromPartyId"/>
                    <select-field field-name="userId"/></entity-find>

                <entity-find-one entity-name="mantle.party.Party" value-field="fromParty" auto-field-map="[partyId:document.fromPartyId]"/>
                <set field="document.fromPseudoId" from="fromParty.pseudoId"/>
                <entity-find entity-name="mantle.party.PartyContent" list="accountContentList">
                    <econdition field-name="partyId" from="document.fromPartyId"/>
                    <econdition field-name="partyContentTypeEnumId" value="PcntPrimaryImage"/>
                    <econdition field-name="contentLocation" operator="is-not-null"/>
                    <select-field field-name="partyId, pseudoId, partyContentId, contentLocation"/>
                    <order-by field-name="-contentDate"/>
                </entity-find>
                <if condition="accountContentList"><set field="document.contentUrl" from="'/custom/downloadPartyContent?partyContentId=' + accountContentList.getFirst().partyContentId"/></if>
                <set field="document.sent" from="false" type="Boolean"/>

                <script><![CDATA[
                    def nm = ec.makeNotificationMessage()
                    nm.topic((String) document._type).message((Map<String, Object>) document)
                    if (toUserAccountList) nm.userIds(new HashSet(toUserAccountList*.userId))
                    nm.send()

                    // Clone document to avoid race condition in document.sent
                    document = new HashMap(document)
                    ]]></script>

                <entity-find entity-name="mantle.party.PartyRelationship" list="fromPartyRelationshipList">
                    <econdition field-name="relationshipTypeEnumId" value="PrtManager"/>
                    <econdition field-name="toRoleTypeId" value="ClientManager"/>
                    <econdition field-name="toPartyId" from="document.fromPartyId"/>
                    <date-filter/>
                </entity-find>

                <entity-find entity-name="moqui.security.UserAccount" list="fromUserAccountList">
                    <econdition field-name="partyId" operator="in" from="fromPartyRelationshipList*.fromPartyId"/>
                    <select-field field-name="userId"/></entity-find>

                <set field="document.sent" from="true" type="Boolean"/>

                <script><![CDATA[
                    nm = ec.makeNotificationMessage()
                    nm.topic((String) document._type).message((Map<String, Object>) document)
                    if (fromUserAccountList) nm.userIds(new HashSet(fromUserAccountList*.userId))
                    nm.send()
                    ]]></script>
            </iterate>
        </actions>
    </service>

    <service verb="send" noun="ProjectNotification" authenticate="false">
        <in-parameters>
        </in-parameters>
        <out-parameters>
        </out-parameters>
        <actions>
            <!-- Notifications have 3 time periods: 1 week, 1 day, 3 hours with and 2/3 tolerance window if notifications haven't been sent -->
            <set field="nowTimestamp" from="ec.user.getNowTimestamp()"/>
            <set field="weekEndDate" from="Timestamp.from(ZonedDateTime.ofInstant(Instant.ofEpochMilli((long) nowTimestamp.time), ZoneId.systemDefault()).plusWeeks(1).toInstant())"/>
            <set field="weekStartDate" from="new Timestamp(weekEndDate.time - ((weekEndDate.time - nowTimestamp.time) * 2/3) as long)"/>
            <set field="dayEndDate" from="Timestamp.from(ZonedDateTime.ofInstant(Instant.ofEpochMilli((long) nowTimestamp.time), ZoneId.systemDefault()).plusDays(1).toInstant())"/>
            <set field="dayStartDate" from="new Timestamp(dayEndDate.time - ((dayEndDate.time - nowTimestamp.time) * 2/3) as long)"/>
            <set field="hourEndDate" from="Timestamp.from(ZonedDateTime.ofInstant(Instant.ofEpochMilli((long) nowTimestamp.time), ZoneId.systemDefault()).plusHours(3).toInstant())"/>
            <set field="hourStartDate" from="new Timestamp(hourEndDate.time - ((hourEndDate.time - nowTimestamp.time) * 2/3) as long)"/>
            <!-- Find the projects that are starting in the next week, day, or 3 hours with a tolerance of 2/3s -->
            <entity-find entity-name="mantle.work.effort.WorkEffort" list="projectList">
                <econdition field-name="workEffortTypeEnumId" value="WetProject"/>
                <econdition field-name="purposeEnumId" value="WepPrResistProject"/>
                <econditions combine="or">
                    <econditions>
                        <econdition field-name="estimatedStartDate" operator="greater-equals" from="weekStartDate"/>
                        <econdition field-name="estimatedStartDate" operator="less" from="weekEndDate"/>
                    </econditions>
                    <econditions>
                        <econdition field-name="estimatedStartDate" operator="greater-equals" from="dayStartDate"/>
                        <econdition field-name="estimatedStartDate" operator="less" from="dayEndDate"/>
                    </econditions>
                    <econditions>
                        <econdition field-name="estimatedStartDate" operator="greater-equals" from="hourStartDate"/>
                        <econdition field-name="estimatedStartDate" operator="less" from="hourEndDate"/>
                    </econditions>
                </econditions>
                <order-by field-name="-lastUpdatedStamp"/>
            </entity-find>

            <iterate list="projectList" entry="workEffort">
                <!-- Find the profiles that are assigned to the project whether they are a talent of manager -->
                <entity-find entity-name="mantle.work.effort.WorkEffortParty" list="projectPositionList">
                    <econdition field-name="workEffortId" from="workEffort.workEffortId"/>
                    <econdition field-name="statusId" value="WeptAssigned"/>
                    <econdition field-name="roleTypeId" operator="in" from="['Talent','Manager']"/>
                    <date-filter/>
                </entity-find>

                <!-- Find the parties of the profiles assigned to the Project-->
                <entity-find entity-name="mantle.party.PartyRelationship" list="partyRelationshipList">
                    <econdition field-name="relationshipTypeEnumId" value="PrtManager"/>
                    <econdition field-name="toRoleTypeId" value="ClientManager"/>
                    <econdition field-name="toPartyId" from="projectPositionList*.partyId"/>
                    <date-filter/>
                </entity-find>

                <!-- Find the user accounts of the party's profile assigned to the Project-->
                <entity-find entity-name="moqui.security.UserAccount" list="userAccountList">
                    <econdition field-name="partyId" operator="in" from="partyRelationshipList*.fromPartyId"/>
                </entity-find>

                <set field="filteredUserAccountList" from="[]"/>
                <iterate list="userAccountList" entry="userAccount">
                    <set field="projectWeekStartDate" from="Timestamp.from(ZonedDateTime.ofInstant(Instant.ofEpochMilli((long) workEffort.estimatedStartDate.time), ZoneId.systemDefault()).minusWeeks(1).toInstant())"/>
                    <set field="projectWeekEndDate" from="new Timestamp(projectWeekStartDate.time + ((workEffort.estimatedStartDate.time - projectWeekStartDate.time) * 2/3) as long)"/>
                    <set field="projectDayStartDate" from="Timestamp.from(ZonedDateTime.ofInstant(Instant.ofEpochMilli((long) workEffort.estimatedStartDate.time), ZoneId.systemDefault()).minusDays(1).toInstant())"/>
                    <set field="projectDayEndDate" from="new Timestamp(projectDayStartDate.time + ((workEffort.estimatedStartDate.time - projectDayStartDate.time) * 2/3) as long)"/>
                    <set field="projectHourStartDate" from="Timestamp.from(ZonedDateTime.ofInstant(Instant.ofEpochMilli((long) workEffort.estimatedStartDate.time), ZoneId.systemDefault()).minusHours(3).toInstant())"/>
                    <set field="projectHourEndDate" from="new Timestamp(projectHourStartDate.time + ((workEffort.estimatedStartDate.time - projectHourStartDate.time) * 2/3) as long)"/>

                    <!-- If multiple notifications are being sent after the system being down for a while (not likely) check sentDate nowTimestamp
                    difference because this assumes they are the same and the difference is the time it takes to run this program -->
                    <entity-find-count entity-name="moqui.security.user.NotificationMessageByUser" count-field="notificationMessageUserCount">
                        <econdition field-name="userId" from="userAccount.userId"/>
                        <econdition field-name="subTopic" from="workEffort.workEffortId"/>
                        <econdition field-name="topic" value="ResistProjectReminder"/>
                        <econditions combine="or">
                            <econditions>
                                <econdition field-name="sentDate" operator="greater-equals" from="projectWeekStartDate" ignore="projectWeekEndDate &lt; nowTimestamp || projectWeekStartDate &gt; nowTimestamp"/>
                                <econdition field-name="sentDate" operator="less" from="projectWeekEndDate" ignore="projectWeekEndDate &lt; nowTimestamp || projectWeekStartDate &gt; nowTimestamp"/>
                            </econditions>
                            <econditions>
                                <econdition field-name="sentDate" operator="greater-equals" from="projectDayStartDate" ignore="projectDayEndDate &lt; nowTimestamp || projectDayStartDate &gt; nowTimestamp"/>
                                <econdition field-name="sentDate" operator="less" from="projectDayEndDate" ignore="projectDayEndDate &lt; nowTimestamp || projectDayStartDate &gt; nowTimestamp"/>
                            </econditions>
                            <econditions>
                                <econdition field-name="sentDate" operator="greater-equals" from="projectHourStartDate" ignore="projectHourEndDate &lt; nowTimestamp || projectHourStartDate &gt; nowTimestamp"/>
                                <econdition field-name="sentDate" operator="less" from="projectHourEndDate" ignore="projectHourEndDate &lt; nowTimestamp || projectHourStartDate &gt; nowTimestamp"/>
                            </econditions>
                        </econditions>
                    </entity-find-count>

                    <if condition="notificationMessageUserCount == 0">
                        <script>filteredUserAccountList.add(userAccount)</script>
                    </if>
                </iterate>

                <!-- Create the title of the notification message -->
                <!-- Week Time: Wednesday November 2nd at 3pm -->
                <!-- Day Time: 3pm (Tomorrow||Today) the November 2nd -->
                <!-- Hour Time: In 2 hours 45 minutes [round to 15 minutes before] at 3pm (Tomorrow||Today) November 2nd -->
                <set field="title" value="${workEffort?.workEffortName ?: 'Your Project'} is starting "/>
                <set field="startPeriod" from="new org.joda.time.MutablePeriod(nowTimestamp.time, workEffort.estimatedStartDate.time)"/>
                <if condition="weekStartDate &lt;= workEffort.estimatedStartDate &amp;&amp; workEffort.estimatedStartDate &lt; weekEndDate">
                    <script>
                        title += ' at '
                        title += new org.joda.time.format.DateTimeFormatterBuilder()
                                .appendDayOfWeekText()
                                .appendLiteral(' ')
                                .appendMonthOfYearText()
                                .appendLiteral(' ')
                                .appendDayOfMonth(1)
                                .appendLiteral(' at ')
                                .appendClockhourOfHalfday(1)
                                .appendHalfdayOfDayText()
                                .toFormatter()
                                .print(workEffort.estimatedStartDate.time)
                    </script>
                </if>
                <if condition="dayStartDate &lt;= workEffort.estimatedStartDate &amp;&amp; workEffort.estimatedStartDate &lt; dayEndDate">
                    <script>
                        title += ' at '
                        title += new org.joda.time.format.DateTimeFormatterBuilder()
                                .appendClockhourOfHalfday(1)
                                .appendHalfdayOfDayText()
                                .appendLiteral(' ')
                                .appendMonthOfYearText()
                                .appendLiteral(' ')
                                .appendDayOfMonth(1)
                                .toFormatter()
                                .print(workEffort.estimatedStartDate.time)
                    </script>
                </if>
                <if condition="hourStartDate &lt;= workEffort.estimatedStartDate &amp;&amp; workEffort.estimatedStartDate &lt; hourEndDate">
                    <script>
                        title += 'in '
                        title += new org.joda.time.format.PeriodFormatterBuilder()
                            .printZeroNever()
                            .appendHours()
                            .appendSuffix(' hour ', ' hours ')
                            .appendMinutes()
                            .appendSuffix(' minute', ' minutes')
                            .toFormatter()
                            .print(startPeriod)
                        title += ' at '
                        title += new org.joda.time.format.DateTimeFormatterBuilder()
                            .appendClockhourOfHalfday(1)
                            .appendHalfdayOfDayText()
                            .appendLiteral(' on ')
                            .appendMonthOfYearText()
                            .appendLiteral(' ')
                            .appendDayOfMonth(1)
                            .toFormatter()
                            .print(workEffort.estimatedStartDate.time)
                    </script>
                </if>

                <script><![CDATA[
                    def nm = ec.makeNotificationMessage()
                    nm.topic("ResistProjectReminder").message(workEffort).subTopic(workEffort.workEffortId).title(title)
                    if (filteredUserAccountList) nm.userIds(new HashSet(filteredUserAccountList*.userId))
                    nm.send(true)
                    ]]></script>
            </iterate>
        </actions>
    </service>
    <!-- End Notification Services -->

    <!-- Image upload services -->
    <!--
    This could certainly improve and be more flexible; if you end up doing this, would be worth contributing back to the moqui-image repository.

    The decisions here to use javax.imageio and not the ImageMagick, NativeMagick, or similar are because using the Java libraries would
    allow this to be used in a Java-only environment for Moqui upstream and limiting the complexity of the code and deployment.

    There are some problems with uploading images of specific color formats and file type conversions (especially svg 1.0
    and in general) that aren't handled well. I'm not sure exactly what the problems are with this, but it's something too
    technical about image conversion that I didn't have time to figure out.

    The process of image uploading could be increased in speed by using async service calls, but handling errors and retaining
    updated file names seemed to require sync service calls. It might be possible to have async service calls return data with
    the commonly used async await pattern, but that currently isn't implemented in Moqui. There may be another solution to this,
    but I haven't found it yet.
    -->
    <service verb="get" noun="ProfilePictureInfo">
        <description>
            This is used to create a svg that is used for default profile pictures see DefaultProfilePicture.xml for uses.
        </description>
        <in-parameters>
            <parameter name="partyId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="firstChar" required="true"/>
            <parameter name="primaryColor" required="true"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.party.Party" value-field="party">
                <field-map field-name="partyId"/></entity-find-one>
            <set field="firstChar" from="(party?.pseudoId ?: '?')[0].toUpperCase()"/>
            <set field="colorList" type="NewList" from="['#fbf8ccff', '#fde4cfff', '#ffcfd2ff', '#f1c0e8ff', '#cfbaf0ff', '#a3c4f3ff', '#90dbf4ff', '#8eecf5ff', '#98f5e1ff', '#b9fbc0ff']"/>
            <set field="primaryColor" from="colorList[Math.abs( new Random().nextInt(colorList.size()) )]"/>
        </actions>
    </service>

    <!-- This is used to get the list of supported image file mime types for internal conversion services for displaying in a browser. -->
    <service verb="get" noun="SupportedImageFileTypeList">
        <in-parameters>
            <parameter name="supportedImageFileTypeList" type="List" default="['image/jpeg', 'image/png', 'image/svg+xml', 'image/webp', 'image/apng', 'image/avif', 'image/gif']"><description>
                See: https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Image_types for this list.</description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="supportedImageFileTypeList" type="List"/>
        </out-parameters>
        <actions></actions>
    </service>

    <service verb="upload" noun="ProfilePictureAttachment">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
            <parameter name="defaultFileName" default-value="DefaultProfilePicture.svg" required="true"/>
            <parameter name="defaultFileRenderLocation" default-value="component://resistmanagement/screen/resistmanagement/DefaultProfilePicture.xml" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyContentId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.check#AccountEdit" in-map="[partyId:partyId]" out-map="context"/>
            <if condition="!allowed"><return type="danger" error="true" message="Not allowed to edit this account"/></if>

            <service-call name="resistmanagement.ResistServices.upload#ProfilePictureAttachmentInternal" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="upload" noun="ProfilePictureResource">
        <description>
            Upload a file for a Party to create a PartyContent entry.

            If a file is not uploaded, there is no defaultFileName, AND there is no defaultFileRenderLocation, then an error is thrown that a file must be uploaded.
        </description>
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="partyContentTypeEnumId" required="true"/>
            <parameter name="defaultFileName"/>
            <parameter name="defaultFileRenderLocation"><description>Screen location to render the default file. Defaults to the text render mode.</description></parameter>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
            <parameter name="saveContentLocation" type="Boolean" default="true"/>
            <parameter name="fileMimeTypeList" required="true" default="ec.service.sync().name('resistmanagement.ResistServices.get#SupportedImageFileTypeList').call().supportedImageFileTypeList"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyContentId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <if condition="contentFile != null &amp;&amp; !fileMimeTypeList.contains(contentFile.getContentType())">
                <!-- see: https://www.javacodeexamples.com/solution-java-util-regex-patternsyntaxexception-dangling-meta-character-near-index-0/3446 for why not split('+') and is split('\\+') -->
                <!-- see: https://freemarker.apache.org/docs/dgui_misc_autoescaping.html for why not split('\\+') and is split('\\\\+') -->
                <return error="true" message="The file type you used: ${contentFile.getContentType().split('/')[1].split('\\\\+')[0] } is not supported. Please upload a ${fileMimeTypeList.collect{ fileMimeTypeList.indexOf(it) &lt; fileMimeTypeList.size() -1 ? it.split('/')[1].split('\\\\+')[0] : 'or ' + it.split('/')[1].split('\\\\+')[0] }.join(', ')} file format."/>
            </if>
            <if condition="!defaultFileName &amp;&amp; !defaultFileRenderLocation &amp;&amp; contentFile == null"><return error="true" message="File upload is required."/></if>

            <set field="filename" from="contentFile?.getName() ?: defaultFileName"/>
            <if condition="org.moqui.resource.ResourceReference.isTextFilename(filename)"><then>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
            </then><else>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.large.root') ?: 'dbresource://mantle/content'"/>
            </else></if>

            <entity-find entity-name="mantle.party.PartyContent" list="pcList">
                <econdition field-name="partyId"/><econdition field-name="contentLocation" operator="is-not-null"/>
                <econdition field-name="partyContentTypeEnumId"/>
                <select-field field-name="partyContentId"/><select-field field-name="contentLocation"/>
                <order-by field-name="contentDate"/></entity-find>
            <iterate list="pcList" entry="partyContent">
                <script>ec.resource.getLocationReference(partyContent.contentLocation)?.delete()</script>
                <service-call name="delete#mantle.party.PartyContent" in-map="[partyContentId:partyContent.partyContentId]"/></iterate>

            <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:partyContentTypeEnumId]" out-map="context"/>

            <set field="contentLocation" value="${contentRoot}/party/${partyId}/content_${partyContentId}/${filename}"/>

            <set field="docRr" from="ec.resource.getLocationReference(contentLocation)"/>
            <script>
                fileStream = contentFile?.getName() ? contentFile.getInputStream() : new ByteArrayInputStream(ec.screen.makeRender().rootScreen(defaultFileRenderLocation).webappName(null).renderMode('text').render().getBytes())
                try { docRr.putStream(fileStream) } finally { fileStream.close() }
            </script>

            <if condition="saveContentLocation"><service-call name="update#mantle.party.PartyContent"
                    in-map="[partyContentId:partyContentId, contentLocation:contentLocation]"/></if>
        </actions>
    </service>

    <service verb="upload" noun="ProfilePictureAttachmentInternal">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
            <parameter name="outputImageFormat" required="true" default-value="jpg"></parameter>
            <parameter name="saveOriginal" type="Boolean" default="false" required="true"><description>If true, will save the original image.</description></parameter>
            <parameter name="saveLarge" type="Boolean" default="false" required="true"><description>If true, will save a large image.</description></parameter>
            <parameter name="saveMedium" type="Boolean" default="false" required="true"><description>If true, will save a medium image.</description></parameter>
            <parameter name="saveSmall" type="Boolean" default="true" required="true"><description>If true, will save a small image.</description></parameter>
            <parameter name="saveThumbnail" type="Boolean" default="false" required="true"><description>If true, will save the thumbnail image.</description></parameter>
            <parameter name="contentTypeOriginal" default-value="PcntPrimaryImage" required="true"><description>Party Content Type Enum Id for the Original image.</description></parameter>
            <parameter name="contentTypeLarge" default-value="PcntPrimaryImage" required="true"><description>Party Content Type Enum Id for the Large image.</description></parameter>
            <parameter name="contentTypeMedium" default-value="PcntPrimaryImage" required="true"><description>Party Content Type Enum Id for the Medium image.</description></parameter>
            <parameter name="contentTypeSmall" default-value="PcntPrimaryImage" required="true"><description>Party Content Type Enum Id for the Small image.</description></parameter>
            <parameter name="contentTypeThumbnail" default-value="PcntPrimaryImage" required="true"><description>Party Content Type Enum Id for the Thumbnail image.</description></parameter>
            <parameter name="fileMimeTypeList" type="List" default="ec.service.sync().name('org.moqui.impl.ImageServices.get#ImageReaderMIMETypes').call()?.imageReaderMIMETypes" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyContentId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <if condition="contentFile == null">
                <service-call name="resistmanagement.ResistServices.upload#ProfilePictureResource" in-map="context + [
                    partyContentTypeEnumId:'PcntPrimaryImage', defaultFileName:'DefaultProfilePicture.svg',
                    defaultFileRenderLocation:'component://resistmanagement/screen/resistmanagement/DefaultProfilePicture.xml']" out-map="context"/>
                <return/>
            </if>
            <if condition="contentFile != null &amp;&amp; !fileMimeTypeList.contains(contentFile.getContentType())">
                <!-- see: https://www.javacodeexamples.com/solution-java-util-regex-patternsyntaxexception-dangling-meta-character-near-index-0/3446 for why not split('+') and is split('\\+') -->
                <!-- see: https://freemarker.apache.org/docs/dgui_misc_autoescaping.html for why not split('\\+') and is split('\\\\+') -->
                <return error="true" message="The file type you used: ${contentFile.getContentType().split('/')[1].split('\\\\+')[0] } is not supported. Please upload a ${fileMimeTypeList.collect{ fileMimeTypeList.indexOf(it) &lt; fileMimeTypeList.size() -1 ? it.split('/')[1].split('\\\\+')[0] : 'or ' + it.split('/')[1].split('\\\\+')[0] }.join(', ')} file format."/>
            </if>

            <!-- TODO: Handle contentFile uploads with mime types that aren't supported -->
            <if condition="org.moqui.resource.ResourceReference.isTextFilename(contentFile?.getName())"><then>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
            </then><else>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.large.root') ?: 'dbresource://mantle/content'"/>
            </else></if>

            <set field="fileNameNoExtension" from="contentFile.getName().take(contentFile.getName().lastIndexOf('.'))"/>

            <set field="Original" type="NewMap"/><set field="contentLocationOriginal"/>
            <set field="Large" type="NewMap"/><set field="contentLocationLarge"/>
            <set field="Medium" type="NewMap"/><set field="contentLocationMedium"/>
            <set field="Small" type="NewMap"/><set field="contentLocationSmall"/>
            <set field="Thumbnail" type="NewMap"/><set field="contentLocationThumbnail"/>

            <if condition="saveOriginal">
                <entity-find entity-name="mantle.party.PartyContent" list="pcList">
                    <econdition field-name="partyId"/><econdition field-name="contentLocation" operator="is-not-null"/>
                    <econdition field-name="partyContentTypeEnumId" from="contentTypeOriginal"/>
                    <select-field field-name="partyContentId"/><select-field field-name="contentLocation"/>
                    <order-by field-name="contentDate"/></entity-find>
                <iterate list="pcList" entry="partyContent">
                    <script>ec.resource.getLocationReference(partyContent.contentLocation)?.delete()</script>
                    <service-call name="delete#mantle.party.PartyContent" in-map="[partyContentId:partyContent.partyContentId]"/></iterate>

                <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeOriginal]" out-map="Original"/><set field="contentLocationOriginal" value="${contentRoot}/party/${partyId}/content_${Original.partyContentId}/${fileNameNoExtension}_Original.${outputImageFormat}"/></if>
            <if condition="saveLarge">
                <entity-find entity-name="mantle.party.PartyContent" list="pcList">
                    <econdition field-name="partyId"/><econdition field-name="contentLocation" operator="is-not-null"/>
                    <econdition field-name="partyContentTypeEnumId" from="contentTypeLarge"/>
                    <select-field field-name="partyContentId"/><select-field field-name="contentLocation"/>
                    <order-by field-name="contentDate"/></entity-find>
                <iterate list="pcList" entry="partyContent">
                    <script>ec.resource.getLocationReference(partyContent.contentLocation)?.delete()</script>
                    <service-call name="delete#mantle.party.PartyContent" in-map="[partyContentId:partyContent.partyContentId]"/></iterate>

                <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeLarge]" out-map="Large"/><set field="contentLocationLarge" value="${contentRoot}/party/${partyId}/content_${Large.partyContentId}/${fileNameNoExtension}_Large.${outputImageFormat}"/></if>
            <if condition="saveMedium">
                <entity-find entity-name="mantle.party.PartyContent" list="pcList">
                    <econdition field-name="partyId"/><econdition field-name="contentLocation" operator="is-not-null"/>
                    <econdition field-name="partyContentTypeEnumId" from="contentTypeMedium"/>
                    <select-field field-name="partyContentId"/><select-field field-name="contentLocation"/>
                    <order-by field-name="contentDate"/></entity-find>
                <iterate list="pcList" entry="partyContent">
                    <script>ec.resource.getLocationReference(partyContent.contentLocation)?.delete()</script>
                    <service-call name="delete#mantle.party.PartyContent" in-map="[partyContentId:partyContent.partyContentId]"/></iterate>

                <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeMedium]" out-map="Medium"/><set field="contentLocationMedium" value="${contentRoot}/party/${partyId}/content_${Medium.partyContentId}/${fileNameNoExtension}_Medium.${outputImageFormat}"/></if>
            <if condition="saveSmall">
                <entity-find entity-name="mantle.party.PartyContent" list="pcList">
                    <econdition field-name="partyId"/><econdition field-name="contentLocation" operator="is-not-null"/>
                    <econdition field-name="partyContentTypeEnumId" from="contentTypeSmall"/>
                    <select-field field-name="partyContentId"/><select-field field-name="contentLocation"/>
                    <order-by field-name="contentDate"/></entity-find>
                <iterate list="pcList" entry="partyContent">
                    <script>ec.resource.getLocationReference(partyContent.contentLocation)?.delete()</script>
                    <service-call name="delete#mantle.party.PartyContent" in-map="[partyContentId:partyContent.partyContentId]"/></iterate>

                <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeSmall]" out-map="Small"/><set field="contentLocationSmall" value="${contentRoot}/party/${partyId}/content_${Small.partyContentId}/${fileNameNoExtension}_Small.${outputImageFormat}"/></if>
            <if condition="saveThumbnail">
                <entity-find entity-name="mantle.party.PartyContent" list="pcList">
                    <econdition field-name="partyId"/><econdition field-name="contentLocation" operator="is-not-null"/>
                    <econdition field-name="partyContentTypeEnumId" from="contentTypeThumbnail"/>
                    <select-field field-name="partyContentId"/><select-field field-name="contentLocation"/>
                    <order-by field-name="contentDate"/></entity-find>
                <iterate list="pcList" entry="partyContent">
                    <script>ec.resource.getLocationReference(partyContent.contentLocation)?.delete()</script>
                    <service-call name="delete#mantle.party.PartyContent" in-map="[partyContentId:partyContent.partyContentId]"/></iterate>

                <service-call name="create#mantle.party.PartyContent" in-map="[partyId:partyId, partyContentTypeEnumId:contentTypeThumbnail]" out-map="Thumbnail"/><set field="contentLocationThumbnail" value="${contentRoot}/party/${partyId}/content_${Thumbnail.partyContentId}/${fileNameNoExtension}_Thumbnail.${outputImageFormat}"/></if>

            <service-call name="org.moqui.impl.ImageServices.convert#Image" in-map="[
                inputImageStream:contentFile.getInputStream(),
                outputImageFormat:outputImageFormat,
                outputResourceReferenceOriginal:ec.resource.getLocationReference(contentLocationOriginal),
                outputResourceReferenceLarge:ec.resource.getLocationReference(contentLocationLarge),
                outputResourceReferenceMedium:ec.resource.getLocationReference(contentLocationMedium),
                outputResourceReferenceSmall:ec.resource.getLocationReference(contentLocationSmall),
                outputResourceReferenceThumbnail:ec.resource.getLocationReference(contentLocationThumbnail),
            ]" out-map="context"/>

            <if condition="saveOriginal"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Original.partyContentId, contentLocation:contentLocationOriginal, contentDate:ec.user.nowTimestamp]"/></if>
            <if condition="saveLarge"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Large.partyContentId, contentLocation:contentLocationLarge, contentDate:ec.user.nowTimestamp]"/></if>
            <if condition="saveMedium"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Medium.partyContentId, contentLocation:contentLocationMedium, contentDate:ec.user.nowTimestamp]"/></if>
            <if condition="saveSmall"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Small.partyContentId, contentLocation:contentLocationSmall, contentDate:ec.user.nowTimestamp]"/></if>
            <if condition="saveThumbnail"><service-call name="update#mantle.party.PartyContent" in-map="[partyContentId:Thumbnail.partyContentId, contentLocation:contentLocationThumbnail, contentDate:ec.user.nowTimestamp]"/></if>
        </actions>
    </service>

    <service verb="upload" noun="PostAttachment">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
            <parameter name="outputImageFormat" required="true" default-value="jpg"></parameter>
            <parameter name="saveOriginal" type="Boolean" default-value="true" required="true"><description>If true, will save the original image.</description></parameter>
            <parameter name="saveLarge" type="Boolean" default-value="false" required="true"><description>If true, will save a large image.</description></parameter>
            <parameter name="saveMedium" type="Boolean" default-value="true" required="true"><description>If true, will save a medium image.</description></parameter>
            <parameter name="saveSmall" type="Boolean" default-value="true" required="true"><description>If true, will save a small image.</description></parameter>
            <parameter name="saveThumbnail" type="Boolean" default-value="false" required="true"><description>If true, will save the thumbnail image.</description></parameter>
            <parameter name="contentTypeOriginal" default-value="CmctImageOriginal" required="true"><description>Party Content Type Enum Id for the Original image.</description></parameter>
            <parameter name="contentTypeLarge" default-value="CmctImageLarge" required="true"><description>Party Content Type Enum Id for the Large image.</description></parameter>
            <parameter name="contentTypeMedium" default-value="CmctImageMedium" required="true"><description>Party Content Type Enum Id for the Medium image.</description></parameter>
            <parameter name="contentTypeSmall" default-value="CmctImageSmall" required="true"><description>Party Content Type Enum Id for the Small image.</description></parameter>
            <parameter name="contentTypeThumbnail" default-value="CmctImageThumbnail" required="true"><description>Party Content Type Enum Id for the Thumbnail image.</description></parameter>
            <parameter name="fileMimeTypeList" type="List" default="ec.service.sync().name('org.moqui.impl.ImageServices.get#ImageReaderMIMETypes').call()?.imageReaderMIMETypes" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="communicationEventId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <if condition="contentFile != null &amp;&amp; !fileMimeTypeList.contains(contentFile.getContentType())">
                <!-- see: https://www.javacodeexamples.com/solution-java-util-regex-patternsyntaxexception-dangling-meta-character-near-index-0/3446 for why not split('+') and is split('\\+') -->
                <!-- see: https://freemarker.apache.org/docs/dgui_misc_autoescaping.html for why not split('\\+') and is split('\\\\+') -->
                <return error="true" message="The file type you used: ${contentFile.getContentType().split('/')[1].split('\\\\+')[0] } is not supported. Please upload a ${fileMimeTypeList.collect{ fileMimeTypeList.indexOf(it) &lt; fileMimeTypeList.size() -1 ? it.split('/')[1].split('\\\\+')[0] : 'or ' + it.split('/')[1].split('\\\\+')[0] }.join(', ')} file format."/>
            </if>
            <if condition="!defaultFileName &amp;&amp; !defaultFileRenderLocation &amp;&amp; contentFile == null"><return message="File not uploaded"/></if>

            <set field="fileName"/>
            <set field="uploaded" from="true"/>
            <script><![CDATA[
                try { fileName = contentFile?.getFileName() }
                catch (Exception exception) { fileName = contentFile?.getName(); uploaded = false }
                ]]></script>

            <!-- TODO: Handle contentFile uploads with mime types that aren't supported -->
            <if condition="org.moqui.resource.ResourceReference.isTextFilename(fileName)"><then>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
            </then><else>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.large.root') ?: 'dbresource://mantle/content'"/>
            </else></if>

            <entity-find-count entity-name="mantle.party.communication.CommunicationEvent" count-field="ceCount">
                <econdition field-name="fromPartyId" from="partyId"/>
                <econdition field-name="communicationEventTypeId" value="Post"/>
            </entity-find-count>
            <if condition="ceCount &gt;= 12"><return error="true" message="Cannot upload more than 12 Posts"/></if>

            <service-call name="create#mantle.party.communication.CommunicationEvent" in-map="[communicationEventTypeId:'Post',fromPartyId:partyId,entryDate:ec.user.nowTimestamp]" out-map="context"/>

            <if condition="!communicationEventId"><return error="true" message="Something went wrong creating your post. Please try again." type="warning"/></if>

            <set field="fileNameNoExtension" from="fileName?.take(fileName?.lastIndexOf('.'))"/>

            <!-- TODO: Use checksum or equivalent from original to check for duplicates. -->
            <!--            <entity-find entity-name="mantle.party.PartyContent" list="pcDuplicateList">-->
            <!--                <econdition field-name="partyId"/>-->
            <!--                <econdition field-name="partyContentTypeEnumId"/>-->
            <!--                <econdition field-name="contentLocation" operator="like" value="${contentRoot}/party/${partyId}/content_%/${fileNameNoExtension}_Original.${outputImageFormat}" ignore-if-empty="true"/>-->
            <!--                <order-by field-name="-contentDate"/></entity-find>-->
            <!--            <set field="partyContentId" from="pcDuplicateList?.getFirst()?.partyContentId"/>-->
            <!--            <if condition="!partyContentId &amp;&amp; pcDuplicateList?.size() == 0">-->

            <set field="Original" type="NewMap"/><set field="contentLocationOriginal"/>
            <set field="Large" type="NewMap"/><set field="contentLocationLarge"/>
            <set field="Medium" type="NewMap"/><set field="contentLocationMedium"/>
            <set field="Small" type="NewMap"/><set field="contentLocationSmall"/>
            <set field="Thumbnail" type="NewMap"/><set field="contentLocationThumbnail"/>

            <if condition="saveOriginal"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeOriginal,sequenceNum:01]" out-map="Original"/><set field="contentLocationOriginal" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Original.communicationEventContentId}/${fileNameNoExtension}_Original.${outputImageFormat}"/></if>
            <if condition="saveLarge"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeLarge,sequenceNum:01]" out-map="Large"/><set field="contentLocationLarge" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Large.communicationEventContentId}/${fileNameNoExtension}_Large.${outputImageFormat}"/></if>
            <if condition="saveMedium"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeMedium,sequenceNum:01]" out-map="Medium"/><set field="contentLocationMedium" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Medium.communicationEventContentId}/${fileNameNoExtension}_Medium.${outputImageFormat}"/></if>
            <if condition="saveSmall"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeSmall,sequenceNum:01]" out-map="Small"/><set field="contentLocationSmall" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Small.communicationEventContentId}/${fileNameNoExtension}_Small.${outputImageFormat}"/></if>
            <if condition="saveThumbnail"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeThumbnail,sequenceNum:01]" out-map="Thumbnail"/><set field="contentLocationThumbnail" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Thumbnail.communicationEventContentId}/${fileNameNoExtension}_Thumbnail.${outputImageFormat}"/></if>

            <if condition="uploaded">
                <service-call name="org.moqui.impl.ImageServices.convert#Image" in-map="[
                    inputImageStream:contentFile?.openStream(),
                    outputImageFormat:outputImageFormat,
                    outputResourceReferenceOriginal:ec.resource.getLocationReference(contentLocationOriginal),
                    outputResourceReferenceLarge:ec.resource.getLocationReference(contentLocationLarge),
                    outputResourceReferenceMedium:ec.resource.getLocationReference(contentLocationMedium),
                    outputResourceReferenceSmall:ec.resource.getLocationReference(contentLocationSmall),
                    outputResourceReferenceThumbnail:ec.resource.getLocationReference(contentLocationThumbnail),
                ]" out-map="context"/>
                <else>
                    <service-call name="org.moqui.impl.ImageServices.convert#Image" in-map="[
                    inputImageStream:contentFile?.getInputStream(),
                    outputImageFormat:outputImageFormat,
                    outputResourceReferenceOriginal:ec.resource.getLocationReference(contentLocationOriginal),
                    outputResourceReferenceLarge:ec.resource.getLocationReference(contentLocationLarge),
                    outputResourceReferenceMedium:ec.resource.getLocationReference(contentLocationMedium),
                    outputResourceReferenceSmall:ec.resource.getLocationReference(contentLocationSmall),
                    outputResourceReferenceThumbnail:ec.resource.getLocationReference(contentLocationThumbnail),
                ]" out-map="context"/>
                </else></if>

            <if condition="saveOriginal"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Original.communicationEventContentId, contentLocation:contentLocationOriginal]"/></if>
            <if condition="saveLarge"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Large.communicationEventContentId, contentLocation:contentLocationLarge]"/></if>
            <if condition="saveMedium"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Medium.communicationEventContentId, contentLocation:contentLocationMedium]"/></if>
            <if condition="saveSmall"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Small.communicationEventContentId, contentLocation:contentLocationSmall]"/></if>
            <if condition="saveThumbnail"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Thumbnail.communicationEventContentId, contentLocation:contentLocationThumbnail]"/></if>
        </actions>
    </service>

    <service verb="upload" noun="PostAttachmentResourceInternal">
        <in-parameters>
            <parameter name="partyId" required="true"/>
            <parameter name="contentFileLocation" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyContentId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <set field="contentFile" from="ec.resource.getLocationReference(contentFileLocation)" type="moqui.org.resource.ResourceReference"/>
            <service-call name="resistmanagement.ResistServices.upload#PostAttachment" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="upload" noun="ProjectPostAttachmentResourceInternal">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="contentFileLocation" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="communicationEventId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <set field="contentFile" from="ec.resource.getLocationReference(contentFileLocation)" type="moqui.org.resource.ResourceReference"/>
            <service-call name="resistmanagement.ResistServices.upload#ProjectPostAttachment" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="upload" noun="ProjectPostAttachment">
        <in-parameters>
            <parameter name="workEffortId" required="true"/>
            <parameter name="contentFile" type="org.apache.commons.fileupload.FileItem"/>
            <parameter name="outputImageFormat" required="true" default-value="jpg"></parameter>
            <parameter name="saveOriginal" type="Boolean" default-value="true" required="true"><description>If true, will save the original image.</description></parameter>
            <parameter name="saveLarge" type="Boolean" default-value="false" required="true"><description>If true, will save a large image.</description></parameter>
            <parameter name="saveMedium" type="Boolean" default-value="true" required="true"><description>If true, will save a medium image.</description></parameter>
            <parameter name="saveSmall" type="Boolean" default-value="true" required="true"><description>If true, will save a small image.</description></parameter>
            <parameter name="saveThumbnail" type="Boolean" default-value="false" required="true"><description>If true, will save the thumbnail image.</description></parameter>
            <parameter name="contentTypeOriginal" default-value="CmctImageOriginal" required="true"><description>Party Content Type Enum Id for the Original image.</description></parameter>
            <parameter name="contentTypeLarge" default-value="CmctImageLarge" required="true"><description>Party Content Type Enum Id for the Large image.</description></parameter>
            <parameter name="contentTypeMedium" default-value="CmctImageMedium" required="true"><description>Party Content Type Enum Id for the Medium image.</description></parameter>
            <parameter name="contentTypeSmall" default-value="CmctImageSmall" required="true"><description>Party Content Type Enum Id for the Small image.</description></parameter>
            <parameter name="contentTypeThumbnail" default-value="CmctImageThumbnail" required="true"><description>Party Content Type Enum Id for the Thumbnail image.</description></parameter>
            <parameter name="fileMimeTypeList" type="List" default="ec.service.sync().name('org.moqui.impl.ImageServices.get#ImageReaderMIMETypes').call()?.imageReaderMIMETypes" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="communicationEventId"/>
            <parameter name="attachmentReference" type="org.moqui.content.ResourceReference"/>
        </out-parameters>
        <actions>
            <if condition="contentFile != null &amp;&amp; !fileMimeTypeList.contains(contentFile.getContentType())">
                <!-- see: https://www.javacodeexamples.com/solution-java-util-regex-patternsyntaxexception-dangling-meta-character-near-index-0/3446 for why not split('+') and is split('\\+') -->
                <!-- see: https://freemarker.apache.org/docs/dgui_misc_autoescaping.html for why not split('\\+') and is split('\\\\+') -->
                <return error="true" message="The file type you used: ${contentFile.getContentType().split('/')[1].split('\\\\+')[0] } is not supported. Please upload a ${fileMimeTypeList.collect{ fileMimeTypeList.indexOf(it) &lt; fileMimeTypeList.size() -1 ? it.split('/')[1].split('\\\\+')[0] : 'or ' + it.split('/')[1].split('\\\\+')[0] }.join(', ')} file format."/>
            </if>
            <if condition="!defaultFileName &amp;&amp; !defaultFileRenderLocation &amp;&amp; contentFile == null"><return message="File not uploaded"/></if>

            <set field="fileName"/>
            <set field="uploaded" from="true"/>
            <script><![CDATA[
                try { fileName = contentFile?.getFileName() }
                catch (Exception exception) { fileName = contentFile?.getName(); uploaded = false }
                ]]></script>

            <!-- TODO: Handle contentFile uploads with mime types that aren't supported -->
            <if condition="org.moqui.resource.ResourceReference.isTextFilename(fileName)"><then>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.root') ?: 'dbresource://mantle/content'"/>
            </then><else>
                <set field="contentRoot" from="ec.user.getPreference('mantle.content.large.root') ?: 'dbresource://mantle/content'"/>
            </else></if>

            <entity-find-count entity-name="mantle.party.communication.CommunicationEventAndContentWithWorkEffort" count-field="ceCount">
                <econdition field-name="effortWorkEffortId" from="workEffortId"/>
                <econdition field-name="eventCommunicationEventTypeId" value="Post"/>
                <econdition field-name="eventContentContentTypeEnumId" value="CmctImageSmall"/>
            </entity-find-count>
            <!--            <log level="warn" message="ceCount ${ceCount}"/>-->
            <if condition="ceCount &gt;= 12"><return error="true" message="Cannot upload more than 12 Posts"/></if>

            <service-call name="create#mantle.party.communication.CommunicationEvent" in-map="[communicationEventTypeId:'Post',entryDate:ec.user.nowTimestamp]" out-map="context"/>
            <service-call name="create#mantle.work.effort.WorkEffortCommEvent" in-map="[workEffortId:workEffortId,communicationEventId:communicationEventId]"/>

            <if condition="!communicationEventId"><return error="true" message="Something went wrong creating your post. Please try again." type="warning"/></if>

            <set field="fileNameNoExtension" from="fileName?.take(fileName?.lastIndexOf('.'))"/>

            <!-- TODO: Use checksum or similar from original to check for duplicates. -->
            <!--            <entity-find entity-name="mantle.party.PartyContent" list="pcDuplicateList">-->
            <!--                <econdition field-name="partyId"/>-->
            <!--                <econdition field-name="partyContentTypeEnumId"/>-->
            <!--                <econdition field-name="contentLocation" operator="like" value="${contentRoot}/party/${partyId}/content_%/${fileNameNoExtension}_Original.${outputImageFormat}" ignore-if-empty="true"/>-->
            <!--                <order-by field-name="-contentDate"/></entity-find>-->
            <!--            <set field="partyContentId" from="pcDuplicateList?.getFirst()?.partyContentId"/>-->
            <!--            <if condition="!partyContentId &amp;&amp; pcDuplicateList?.size() == 0">-->

            <set field="Original" type="NewMap"/><set field="contentLocationOriginal"/>
            <set field="Large" type="NewMap"/><set field="contentLocationLarge"/>
            <set field="Medium" type="NewMap"/><set field="contentLocationMedium"/>
            <set field="Small" type="NewMap"/><set field="contentLocationSmall"/>
            <set field="Thumbnail" type="NewMap"/><set field="contentLocationThumbnail"/>

            <if condition="saveOriginal"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeOriginal,sequenceNum:01]" out-map="Original"/><set field="contentLocationOriginal" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Original.communicationEventContentId}/${fileNameNoExtension}_Original.${outputImageFormat}"/></if>
            <if condition="saveLarge"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeLarge,sequenceNum:01]" out-map="Large"/><set field="contentLocationLarge" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Large.communicationEventContentId}/${fileNameNoExtension}_Large.${outputImageFormat}"/></if>
            <if condition="saveMedium"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeMedium,sequenceNum:01]" out-map="Medium"/><set field="contentLocationMedium" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Medium.communicationEventContentId}/${fileNameNoExtension}_Medium.${outputImageFormat}"/></if>
            <if condition="saveSmall"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeSmall,sequenceNum:01]" out-map="Small"/><set field="contentLocationSmall" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Small.communicationEventContentId}/${fileNameNoExtension}_Small.${outputImageFormat}"/></if>
            <if condition="saveThumbnail"><service-call name="create#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventId:communicationEventId,contentTypeEnumId:contentTypeThumbnail,sequenceNum:01]" out-map="Thumbnail"/><set field="contentLocationThumbnail" value="${contentRoot}/CommunicationEvent/${communicationEventId}/content_${Thumbnail.communicationEventContentId}/${fileNameNoExtension}_Thumbnail.${outputImageFormat}"/></if>

            <if condition="uploaded">
                <service-call name="org.moqui.impl.ImageServices.convert#Image" in-map="[
                    inputImageStream:contentFile?.openStream(),
                    outputImageFormat:outputImageFormat,
                    outputResourceReferenceOriginal:ec.resource.getLocationReference(contentLocationOriginal),
                    outputResourceReferenceLarge:ec.resource.getLocationReference(contentLocationLarge),
                    outputResourceReferenceMedium:ec.resource.getLocationReference(contentLocationMedium),
                    outputResourceReferenceSmall:ec.resource.getLocationReference(contentLocationSmall),
                    outputResourceReferenceThumbnail:ec.resource.getLocationReference(contentLocationThumbnail),
                ]" out-map="context"/>
                <else>
                    <service-call name="org.moqui.impl.ImageServices.convert#Image" in-map="[
                    inputImageStream:contentFile?.getInputStream(),
                    outputImageFormat:outputImageFormat,
                    outputResourceReferenceOriginal:ec.resource.getLocationReference(contentLocationOriginal),
                    outputResourceReferenceLarge:ec.resource.getLocationReference(contentLocationLarge),
                    outputResourceReferenceMedium:ec.resource.getLocationReference(contentLocationMedium),
                    outputResourceReferenceSmall:ec.resource.getLocationReference(contentLocationSmall),
                    outputResourceReferenceThumbnail:ec.resource.getLocationReference(contentLocationThumbnail),
                ]" out-map="context"/>
                </else></if>

            <if condition="saveOriginal"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Original.communicationEventContentId, contentLocation:contentLocationOriginal]"/></if>
            <if condition="saveLarge"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Large.communicationEventContentId, contentLocation:contentLocationLarge]"/></if>
            <if condition="saveMedium"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Medium.communicationEventContentId, contentLocation:contentLocationMedium]"/></if>
            <if condition="saveSmall"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Small.communicationEventContentId, contentLocation:contentLocationSmall]"/></if>
            <if condition="saveThumbnail"><service-call name="update#mantle.party.communication.CommunicationEventContent" in-map="[communicationEventContentId:Thumbnail.communicationEventContentId, contentLocation:contentLocationThumbnail]"/></if>
        </actions>
    </service>
    <!-- End Image upload services -->

    <!-- Profile Admin Management Services -->
    <service verb="store" noun="EmplPositionClass">
        <in-parameters>
            <parameter name="emplPositionClassId" default="title.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <parameter name="title" required="true"/>
            <parameter name="description"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
        </out-parameters>
        <actions>
            <service-call name="store#mantle.humanres.position.EmplPositionClass" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfileTypeDimensionType">
        <description></description>
        <in-parameters>
            <parameter name="uomDimensionTypeId" default="description.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <parameter name="description" required="true"/>
            <parameter name="uomTypeEnumId"/>
            <parameter name="defaultUomId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="uomDimensionTypeId"/>
        </out-parameters>
        <actions>
            <service-call name="store#moqui.basic.UomDimensionType" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="storeAndAdd" noun="TalentProfileTypeDimensionType">
        <implements service="resistmanagement.ResistServices.store#TalentProfileTypeDimensionType"/>
        <in-parameters>
            <parameter name="emplPositionClassId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
            <parameter name="enumId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.store#TalentProfileTypeDimensionType" in-map="context" out-map="context"/>
            <service-call name="store#mantle.humanres.position.EmplPositionClassDimension" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfileTypeClassificationType">
        <description></description>
        <in-parameters>
            <parameter name="enumId"/>
            <parameter name="enumTypeId" default-value="PartyClassificationType"/>
            <parameter name="enumCode"/>
            <parameter name="sequenceNum"/>
            <parameter name="description" required="true"/>
            <parameter name="optionValue"/>
            <parameter name="optionIndicator"/>
        </in-parameters>
        <out-parameters>
            <parameter name="enumId"/>
        </out-parameters>
        <actions>
            <set field="enumId" from="enumId ?: camelCaseToPretty(enumTypeId).split(' ').collect{ it[0] }.join('').toLowerCase().capitalize() + description.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <service-call name="store#moqui.basic.Enumeration" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="storeAndAdd" noun="TalentProfileTypeClassificationType">
        <implements service="resistmanagement.ResistServices.store#TalentProfileTypeClassificationType"/>
        <in-parameters>
            <parameter name="emplPositionClassId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
            <parameter name="enumId"/>
            <parameter name="classificationTypeEnumId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.store#TalentProfileTypeClassificationType" in-map="context" out-map="context"/>
            <set field="classificationTypeEnumId" from="enumId"/>
            <service-call name="store#mantle.party.EmplPositionClassPtyClsTp" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfileTypeClassificationTypeAttribute">
        <description></description>
        <in-parameters>
            <parameter name="partyClassificationId"/>
            <parameter name="classificationTypeEnumId" required="true"/>
            <parameter name="parentClassificationId"/>
            <parameter name="description" required="true"/>
            <parameter name="standardCode"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyClassificationId"/>
        </out-parameters>
        <actions>
            <set field="partyClassificationId" from="partyClassificationId ?: camelCaseToPretty(classificationTypeEnumId).split(' ')[0].toLowerCase().capitalize() + description.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <service-call name="store#mantle.party.PartyClassification" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="store" noun="TalentProfileTypeSkillType">
        <description></description>
        <in-parameters>
            <parameter name="enumId"/>
            <parameter name="enumTypeId" default-value="SkillType"/>
            <parameter name="enumCode"/>
            <parameter name="sequenceNum"/>
            <parameter name="description" required="true"/>
            <parameter name="optionValue"/>
            <parameter name="optionIndicator"/>
        </in-parameters>
        <out-parameters>
            <parameter name="enumId"/>
        </out-parameters>
        <actions>
            <set field="enumId" from="enumId ?: camelCaseToPretty(enumTypeId).split(' ').collect{ it[0] }.join('').toLowerCase().capitalize() + description.split(' ').collect{ it.toLowerCase().capitalize() }.join('')"/>
            <service-call name="store#moqui.basic.Enumeration" in-map="context" out-map="context"/>
        </actions>
    </service>

    <service verb="storeAndAdd" noun="TalentProfileTypeSkillType">
        <in-parameters>
            <parameter name="emplPositionClassId" required="true"/>
            <parameter name="enumId"/>
            <parameter name="enumTypeId" default-value="SkillType"/>
            <parameter name="enumCode"/>
            <parameter name="sequenceNum"/>
            <parameter name="description" required="true"/>
            <parameter name="optionValue"/>
            <parameter name="optionIndicator"/>
        </in-parameters>
        <out-parameters>
            <parameter name="emplPositionClassId"/>
            <parameter name="enumId"/>
            <parameter name="skillTypeEnumId"/>
        </out-parameters>
        <actions>
            <service-call name="resistmanagement.ResistServices.store#TalentProfileTypeSkillType" in-map="context" out-map="context"/>
            <set field="skillTypeEnumId" from="enumId"/>
            <service-call name="store#mantle.humanres.position.EmplPositionClassSkill" in-map="context" out-map="context"/>
        </actions>
    </service>
    <!-- End Profile Admin Management Services -->
</services>
